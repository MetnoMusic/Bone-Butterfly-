<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bone Butterfly</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IM+Fell+English:ital@0;1&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  :root { --cream:#f0e8d8; --warm:#c8a97a; --dark:#1a1410; }
  body {
    background:var(--dark); color:var(--cream);
    font-family:'IM Fell English',serif;
    height:100dvh; display:flex; flex-direction:column;
    align-items:center; justify-content:center;
    overflow:hidden; user-select:none;
  }
  body::before {
    content:''; position:fixed; inset:0;
    background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
    opacity:0.35; pointer-events:none; z-index:10;
  }
  body::after {
    content:''; position:fixed; inset:0;
    background:radial-gradient(ellipse at center,transparent 30%,rgba(0,0,0,0.78) 100%);
    pointer-events:none; z-index:9;
  }
  canvas { position:fixed; inset:0; width:100%; height:100%; z-index:1; }
  .center {
    position:relative; z-index:20; text-align:center;
    display:flex; flex-direction:column; align-items:center; gap:1.8rem;
  }
  .title { font-size:clamp(2.2rem,8vw,4.8rem); letter-spacing:0.18em; opacity:0.92; font-weight:normal; }
  .subtitle { font-size:clamp(0.72rem,3vw,0.95rem); letter-spacing:0.45em; color:var(--warm); opacity:0.6; font-style:italic; text-transform:uppercase; }
  .btn {
    width:80px; height:80px; border-radius:50%;
    border:1.5px solid rgba(200,169,122,0.4); background:transparent;
    display:flex; align-items:center; justify-content:center;
    cursor:pointer; transition:border-color 0.8s,transform 0.3s; position:relative;
  }
  .btn::before { content:''; position:absolute; inset:-8px; border-radius:50%; border:1px solid rgba(200,169,122,0.12); }
  .btn:hover { border-color:rgba(200,169,122,0.7); transform:scale(1.05); }
  .note-indicator { font-size:clamp(0.9rem,3.5vw,1.2rem); letter-spacing:0.4em; color:var(--warm); opacity:0; transition:opacity 1.4s ease; min-height:1.8em; font-style:italic; }
  .note-indicator.visible { opacity:0.45; }
  .hint { font-size:0.68rem; letter-spacing:0.3em; color:var(--cream); opacity:0.22; text-transform:uppercase; transition:opacity 2s; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="center">
  <p class="subtitle">a piece for many listeners</p>
  <h1 class="title">Bone Butterfly</h1>
  <button class="btn" id="playBtn" aria-label="Play">
    <svg id="btnIcon" width="22" height="22" viewBox="0 0 24 24" fill="#c8a97a"><polygon points="5,3 19,12 5,21"/></svg>
  </button>
  <div class="note-indicator" id="noteDisp"></div>
  <p class="hint" id="hint">tap to begin</p>
</div>

<script>
const rand = (a,b) => a + Math.random()*(b-a);
const pick = arr => arr[Math.floor(Math.random()*arr.length)];
const coin = p => Math.random() < p;

// ── G Mixolydian universe ─────────────────────────────────────────────────────
// G A B C D E F — F natural is the Mixolydian colour note
const MIX = {
  G2:98.00, C3:130.81, D3:146.83, E3:164.81, F3:174.61,
  G3:196.00, A3:220.00, B3:246.94,
  C4:261.63, D4:293.66, E4:329.63, F4:349.23,
  G4:392.00, A4:440.00, B4:493.88,
  C5:523.25, D5:587.33, E5:659.26, F5:698.46,
  G5:784.00, A5:880.00,
};

// Melody notes — expanded to 6 pitches, D and A less frequent than core 4
const MELODY = ['G4','F4','E4','C4','D4','A4'];
const CORE   = ['G4','F4','E4','C4'];   // original four — appear more often
const COLOUR = ['D4','A4'];             // new additions — appear less often

// Voice leading transition weights
// Format: { targetNote: weight } — higher = more likely
// Rules:
//   G → A  : strongly preferred
//   D → E  : strongly preferred
//   E → D  : forbidden (weight 0)
//   A → G  : forbidden (weight 0)
const TRANSITIONS = {
  G4: { A4:5, F4:2, E4:2, C4:2, D4:1 },
  F4: { E4:3, C4:3, G4:2, D4:2, A4:1 },
  E4: { C4:3, G4:3, F4:2, A4:2, D4:0 },
  C4: { G4:3, E4:3, F4:2, D4:2, A4:1 },
  D4: { E4:6, G4:2, F4:1, C4:1, A4:1 },
  A4: { E4:3, F4:3, C4:2, D4:2, G4:0 },
};

// Chord voicings — expanded with D and A
const VOICINGS = {
  G4: ['G2','D3','G3','B3','D4','G4','B4','D5'],
  F4: ['C3','F3','A3','C4','F4','A4','C5','E5'],
  E4: ['G2','E3','B3','E4','G4','B4','E5'],
  C4: ['G2','C3','G3','C4','E4','G4','C5'],
  D4: ['D3','A3','D4','F4','A4','D5'],
  A4: ['A2','E3','A3','C4','E4','A4','C5'],
  GF: ['G2','F3','C4','F4','A4','C5','F5'],
  GE: ['G2','E3','B3','G4','B4','E5'],
  GC: ['G2','C3','G3','C4','E4','G4','D5'],
  FE: ['C3','E3','A3','C4','F4','A4','C5'],
  FC: ['F3','C4','F4','A4','C5','F5'],
  EC: ['C3','E3','G3','C4','E4','G4','B4'],
  DA: ['D3','A3','D4','E4','A4','D5'],
  GA: ['G2','A3','E4','G4','A4','E5'],
  ALL:['G2','A2','C3','E3','G3','B3','D4','F4','G4','A4','C5'],
};

let ctx, reverb, masterLPF, playing=false, lastNote=null;
let timers=[];
const addTimer=(fn,ms)=>{const t=setTimeout(fn,ms);timers.push(t);return t;};
const clearTimers=()=>{timers.forEach(clearTimeout);timers=[];};

// ── Piece memory ──────────────────────────────────────────────────────────────
let recentNotes = [];    // last 6 melody notes played
let noteHistory = [];    // full sequence history
let breathPhase = 'building'; // building | full | withdrawing | silence
let pieceDensity = 1.0;  // multiplier on gap timing
let swellActive=false, swellIntensity=0;
let nextNoteT=0;

// ── Reverb (synthesised impulse response) ─────────────────────────────────────
function buildReverb(actx) {
  const sr=actx.sampleRate, dur=5.0, decay=4.0;
  const len=Math.floor(sr*dur);
  const ir=actx.createBuffer(2,len,sr);
  for (let ch=0;ch<2;ch++) {
    const d=ir.getChannelData(ch);
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0;
    for (let i=0;i<len;i++) {
      const w=Math.random()*2-1;
      b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759;
      b2=0.96900*b2+w*0.1538520; b3=0.86650*b3+w*0.3104856;
      b4=0.55000*b4+w*0.5329522; b5=-0.7616*b5-w*0.0168980;
      d[i]=(b0+b1+b2+b3+b4+b5+w*0.5362)*0.11*Math.pow(1-i/len,decay);
    }
  }
  const conv=actx.createConvolver(); conv.buffer=ir; return conv;
}

// ── Pink noise ────────────────────────────────────────────────────────────────
function makePink(actx,dur) {
  const sr=actx.sampleRate;
  const buf=actx.createBuffer(2,Math.floor(sr*dur),sr);
  for (let ch=0;ch<2;ch++) {
    const d=buf.getChannelData(ch);
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
    for (let i=0;i<d.length;i++) {
      const w=Math.random()*2-1;
      b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759;
      b2=0.96900*b2+w*0.1538520; b3=0.86650*b3+w*0.3104856;
      b4=0.55000*b4+w*0.5329522; b5=-0.7616*b5-w*0.0168980;
      d[i]=(b0+b1+b2+b3+b4+b5+b6+w*0.5362)*0.11; b6=w*0.115926;
    }
  }
  return buf;
}

// ── Tape curve ────────────────────────────────────────────────────────────────
function tapeCurve(amt=35) {
  const n=256,c=new Float32Array(n);
  for (let i=0;i<n;i++){const x=i*2/n-1;c[i]=(Math.PI+amt)*x/(Math.PI+amt*Math.abs(x));}
  return c;
}

// ── Piano note ────────────────────────────────────────────────────────────────
function playNote(actx, freqHz, time, opts={}) {
  const {
    vol=rand(0.10,0.16), decay=rand(4.0,7.0),
    reversed=false, quiet=false, dryWet=0.62,
    wobble=rand(0.997,1.003)
  } = opts;

  const f0=freqHz*wobble;
  const v=quiet?vol*0.4:vol;

  const dryG=actx.createGain(); dryG.gain.value=v*(1-dryWet);
  const wetG=actx.createGain(); wetG.gain.value=v*dryWet;
  dryG.connect(masterLPF); wetG.connect(reverb);

  const preLPF=actx.createBiquadFilter(); preLPF.type='lowpass';
  preLPF.frequency.value=rand(1800,2600); preLPF.Q.value=0.5;
  preLPF.connect(dryG); preLPF.connect(wetG);

  const warmth=actx.createBiquadFilter(); warmth.type='highshelf';
  warmth.frequency.value=4000; warmth.gain.value=rand(-5,-9);
  warmth.connect(preLPF);

  const shaper=actx.createWaveShaper();
  shaper.curve=tapeCurve(rand(20,45)); shaper.oversample='4x';
  shaper.connect(warmth);

  const env=actx.createGain();
  if (reversed) {
    env.gain.setValueAtTime(0.001,time);
    env.gain.exponentialRampToValueAtTime(1.0,time+decay*0.82);
    env.gain.linearRampToValueAtTime(0,time+decay);
  } else {
    env.gain.setValueAtTime(0,time);
    env.gain.linearRampToValueAtTime(1.0,time+0.010);
    env.gain.exponentialRampToValueAtTime(0.38,time+0.15);
    env.gain.exponentialRampToValueAtTime(0.001,time+decay);
  }
  env.connect(shaper);

  // Inharmonic partials — acoustic piano character
  const ih=1.0006;
  [
    {m:1.000,      g:1.00,d:1.00},
    {m:2.000*ih,   g:0.48,d:0.55},
    {m:3.000*ih*ih,g:0.22,d:0.35},
    {m:4*Math.pow(ih,3),g:0.12,d:0.22},
    {m:5*Math.pow(ih,4),g:0.06,d:0.15},
    {m:6*Math.pow(ih,5),g:0.03,d:0.10},
  ].forEach(p=>{
    const osc=actx.createOscillator(); osc.type='sine'; osc.frequency.value=f0*p.m;
    if(p.m<1.1){
      const wow=actx.createOscillator(); wow.frequency.value=rand(0.3,0.8);
      const wg=actx.createGain(); wg.gain.value=rand(0.5,1.5);
      wow.connect(wg); wg.connect(osc.frequency);
      wow.start(time); wow.stop(time+decay+2);
    }
    const pg=actx.createGain();
    pg.gain.setValueAtTime(p.g,time);
    pg.gain.exponentialRampToValueAtTime(0.001,time+decay*p.d);
    osc.connect(pg); pg.connect(env);
    osc.start(time); osc.stop(time+decay+2);
  });

  // Hammer transient
  if (!reversed) {
    const hLen=Math.floor(actx.sampleRate*0.035);
    const hb=actx.createBuffer(1,hLen,actx.sampleRate);
    const hd=hb.getChannelData(0);
    for(let i=0;i<hLen;i++) hd[i]=(Math.random()*2-1)*Math.exp(-i/350)*0.6;
    const hs=actx.createBufferSource(); hs.buffer=hb;
    const hbp=actx.createBiquadFilter(); hbp.type='bandpass';
    hbp.frequency.value=rand(600,1100); hbp.Q.value=2;
    const hg=actx.createGain(); hg.gain.value=rand(0.08,0.15);
    hs.connect(hbp); hbp.connect(hg); hg.connect(wetG);
    hs.start(time); hs.stop(time+0.04);
  }
}

// ── Self-referencing chord bloom ──────────────────────────────────────────────
// Looks at recentNotes, picks the best voicing, fades in a lush chord
function bloomChord(actx) {
  if (!playing || !ctx) return;

  // Analyse what was recently played
  const unique = [...new Set(recentNotes.slice(-6))];
  let voicingKey = 'G4';

  if (unique.length >= 5) {
    voicingKey = 'ALL';
  } else if (unique.length >= 4 && unique.includes('G4') && unique.includes('A4')) {
    voicingKey = 'ALL';
  } else if (unique.includes('D4') && unique.includes('A4')) {
    voicingKey = 'DA';
  } else if (unique.includes('G4') && unique.includes('A4')) {
    voicingKey = 'GA';
  } else if (unique.includes('D4')) {
    voicingKey = 'D4';
  } else if (unique.includes('A4')) {
    voicingKey = 'A4';
  } else if (unique.length >= 4) {
    voicingKey = 'ALL';
  } else if (unique.length === 3) {
    voicingKey = unique.includes('G4') && unique.includes('F4') ? 'GF'
               : unique.includes('G4') && unique.includes('E4') ? 'GE'
               : unique.includes('G4') && unique.includes('C4') ? 'GC'
               : unique.includes('F4') && unique.includes('E4') ? 'FE'
               : unique.includes('F4') && unique.includes('C4') ? 'FC'
               : 'EC';
  } else if (unique.length === 2) {
    if      (unique.includes('G4') && unique.includes('F4')) voicingKey='GF';
    else if (unique.includes('G4') && unique.includes('E4')) voicingKey='GE';
    else if (unique.includes('G4') && unique.includes('C4')) voicingKey='GC';
    else if (unique.includes('F4') && unique.includes('E4')) voicingKey='FE';
    else if (unique.includes('F4') && unique.includes('C4')) voicingKey='FC';
    else if (unique.includes('D4') && unique.includes('A4')) voicingKey='DA';
    else if (unique.includes('G4') && unique.includes('A4')) voicingKey='GA';
    else voicingKey='EC';
  } else if (unique.length === 1) {
    voicingKey = unique[0];
  }

  const notes = VOICINGS[voicingKey] || VOICINGS['G4'];
  const chordDur = rand(8, 16);   // chord sustains for a long time
  const fadeIn   = rand(2.5, 5);  // very slow fade in
  const now = actx.currentTime;

  // Master chord gain — slow fade in and out
  const chordMaster = actx.createGain();
  chordMaster.gain.setValueAtTime(0, now);
  chordMaster.gain.linearRampToValueAtTime(rand(0.06,0.12), now+fadeIn);
  chordMaster.gain.setValueAtTime(rand(0.06,0.12), now+chordDur*0.6);
  chordMaster.gain.linearRampToValueAtTime(0, now+chordDur);

  // Chord goes heavily into reverb for lushness
  const chordWet = actx.createGain(); chordWet.gain.value=0.85;
  const chordDry = actx.createGain(); chordDry.gain.value=0.15;
  chordMaster.connect(chordWet); chordWet.connect(reverb);
  chordMaster.connect(chordDry); chordDry.connect(masterLPF);

  // Very gentle LPF on chord — silky
  const chordLPF = actx.createBiquadFilter();
  chordLPF.type='lowpass'; chordLPF.frequency.value=rand(900,1400); chordLPF.Q.value=0.3;
  chordLPF.connect(chordMaster);

  // Play each note of the chord as a sustained sine with harmonics
  notes.forEach((noteName, i) => {
    const f = MIX[noteName];
    if (!f) return;
    // Stagger entry slightly so chord blooms from bottom to top
    const stagger = i * rand(0.15, 0.4);
    const osc1=actx.createOscillator(); osc1.type='sine'; osc1.frequency.value=f*rand(0.998,1.002);
    const osc2=actx.createOscillator(); osc2.type='sine'; osc2.frequency.value=f*2.001;
    const osc3=actx.createOscillator(); osc3.type='sine'; osc3.frequency.value=f*3.002;

    const og=actx.createGain();
    og.gain.setValueAtTime(0, now+stagger);
    og.gain.linearRampToValueAtTime(1.0/(notes.length*0.7), now+stagger+rand(1,2.5));
    og.gain.setValueAtTime(1.0/(notes.length*0.7), now+chordDur*0.55);
    og.gain.linearRampToValueAtTime(0, now+chordDur-stagger);

    const h2g=actx.createGain(); h2g.gain.value=0.18;
    const h3g=actx.createGain(); h3g.gain.value=0.07;

    osc1.connect(og); og.connect(chordLPF);
    osc2.connect(h2g); h2g.connect(chordLPF);
    osc3.connect(h3g); h3g.connect(chordLPF);

    const end=now+chordDur+2;
    [osc1,osc2,osc3].forEach(o=>{o.start(now+stagger);o.stop(end);});
  });

  // Trigger visual bloom
  chordBloom=true;
  setTimeout(()=>{ chordBloom=false; }, chordDur*1000*0.7);
}

// ── Ocean swell ───────────────────────────────────────────────────────────────
function playOceanSwell(actx) {
  const dur=rand(16,28);
  const buf=makePink(actx,dur);
  const src=actx.createBufferSource(); src.buffer=buf;
  const peak=rand(0.13,0.20);
  const env=actx.createGain();
  env.gain.setValueAtTime(0,actx.currentTime);
  env.gain.linearRampToValueAtTime(peak,actx.currentTime+dur*0.30);
  env.gain.setValueAtTime(peak,actx.currentTime+dur*0.62);
  env.gain.linearRampToValueAtTime(0,actx.currentTime+dur);
  const lpf=actx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=rand(350,550); lpf.Q.value=0.7;
  const body=actx.createBiquadFilter(); body.type='peaking'; body.frequency.value=rand(80,150); body.Q.value=0.5; body.gain.value=rand(4,8);
  const lfo=actx.createOscillator(); lfo.frequency.value=rand(0.03,0.09);
  const lfg=actx.createGain(); lfg.gain.value=rand(0.015,0.04);
  lfo.connect(lfg); lfg.connect(env.gain);
  const sd=actx.createGain(); sd.gain.value=0.55;
  const sw=actx.createGain(); sw.gain.value=0.5;
  src.connect(body); body.connect(lpf); lpf.connect(env);
  env.connect(sd); sd.connect(masterLPF);
  env.connect(sw); sw.connect(reverb);
  lfo.start(); lfo.stop(actx.currentTime+dur);
  src.start(); src.stop(actx.currentTime+dur);
  swellActive=true; swellIntensity=peak/0.20;
  setTimeout(()=>{swellActive=false;swellIntensity=0;},dur*1000);
}

// ── Polyrhythm layer ──────────────────────────────────────────────────────────
function playPolyLayer(actx, ratio, pulseLen, startT) {
  const step=(pulseLen*4)/ratio;
  for(let i=0;i<ratio;i++){
    const name=pick(MELODY); const f=MIX[name];
    playNote(actx,f,startT+i*step,{vol:rand(0.04,0.07),decay:rand(1.8,3.0),quiet:true,dryWet:0.72});
  }
}

// ── Breathing / density arc ───────────────────────────────────────────────────
// The piece breathes: builds density, sits full, then withdraws, rests, rebuilds
function updateBreathPhase() {
  const phases = ['building','full','withdrawing','silence'];
  const durations = {
    building:  rand(45000,90000),
    full:      rand(30000,60000),
    withdrawing: rand(40000,70000),
    silence:   rand(15000,35000),
  };
  const densities = { building:1.0, full:0.85, withdrawing:1.4, silence:2.8 };

  const next = (current) => {
    const idx = phases.indexOf(current);
    return phases[(idx+1)%phases.length];
  };

  const transition = () => {
    if (!playing) return;
    breathPhase = next(breathPhase);
    pieceDensity = densities[breathPhase];
    addTimer(transition, durations[breathPhase]);
  };

  addTimer(transition, durations[breathPhase]);
}

// ── Note picker — weighted transitions + voice leading rules ──────────────────
function pickMelodyNote() {
  let pool = [];

  if (lastNote && TRANSITIONS[lastNote]) {
    // Build pool from transition weights
    const t = TRANSITIONS[lastNote];
    for (const [note, weight] of Object.entries(t)) {
      for (let i=0; i<weight; i++) pool.push(note);
    }
  } else {
    // No last note yet — weight core notes more heavily than colour notes
    for (const n of CORE)   { pool.push(n,n,n); }   // 3x weight
    for (const n of COLOUR) { pool.push(n); }         // 1x weight
  }

  // Memory drift — after 20+ notes, occasionally echo a ghost note from history
  // (only if that ghost note is a legal move from current position)
  if (noteHistory.length > 16 && coin(0.22) && lastNote) {
    const lookback = Math.floor(rand(4,9));
    const ghost = noteHistory[noteHistory.length - lookback];
    const allowed = TRANSITIONS[lastNote] || {};
    if (ghost && (allowed[ghost] || 0) > 0) {
      pool.push(ghost, ghost); // extra pull toward the ghost
    }
  }

  // Remove any notes with weight 0 (forbidden moves) — already excluded
  // but safety: filter out same note if pool has other options
  const filtered = pool.filter(n => n !== lastNote);
  const chosen = filtered.length > 0 ? pick(filtered) : pick(pool);

  lastNote = chosen;
  noteHistory.push(chosen);
  recentNotes.push(chosen);
  if (recentNotes.length > 8) recentNotes.shift();
  if (noteHistory.length > 200) noteHistory.shift();
  return chosen;
}

// ── Main melody scheduler ─────────────────────────────────────────────────────
const noteDisp=document.getElementById('noteDisp');

function scheduleMain() {
  if (!playing||!ctx) return;
  const name = pickMelodyNote();
  const f = MIX[name];
  const isRev = coin(0.12);
  // Gap modulated by breath phase density
  const baseGap = rand(2.8,6.2);
  const gap = baseGap * pieceDensity;
  nextNoteT += gap;

  playNote(ctx, f, nextNoteT, { reversed:isRev, dryWet:0.62 });

  const ms = Math.max(0,(nextNoteT-ctx.currentTime)*1000);
  addTimer(()=>{
    if(!playing) return;
    noteDisp.textContent = isRev ? `↩ ${name.replace(/\d/,'')}` : name.replace(/\d/,'');
    noteDisp.classList.add('visible');
    addTimer(()=>noteDisp.classList.remove('visible'),2200);
    triggerPulse(isRev);
  },ms);

  addTimer(scheduleMain,(gap-1.4)*1000);
}

// ── Chord bloom scheduler ─────────────────────────────────────────────────────
function scheduleChordBloom() {
  if(!playing||!ctx) return;
  const wait = rand(8000,18000); // every 8-18 seconds
  addTimer(()=>{
    if(!playing||!ctx) return;
    if(recentNotes.length >= 2) bloomChord(ctx);
    scheduleChordBloom();
  }, wait);
}

// ── Polyrhythm scheduler ──────────────────────────────────────────────────────
function schedulePolyrhythm() {
  if(!playing||!ctx) return;
  addTimer(()=>{
    if(!playing||!ctx) return;
    if(breathPhase !== 'silence') {
      const ratio=coin(0.5)?5:6, pulse=rand(1.0,1.7);
      const t0=ctx.currentTime+0.5;
      playPolyLayer(ctx,ratio,pulse,t0);
      playPolyLayer(ctx,ratio,pulse,t0+pulse*4+rand(0.5,1.5));
    }
    schedulePolyrhythm();
  }, rand(20000,45000));
}

// ── Ocean swell scheduler ─────────────────────────────────────────────────────
function scheduleOceanSwell() {
  if(!playing||!ctx) return;
  addTimer(()=>{
    if(!playing||!ctx) return;
    if(!swellActive) playOceanSwell(ctx);
    scheduleOceanSwell();
  }, rand(18000,40000));
}

// ── Start / stop ──────────────────────────────────────────────────────────────
function startMusic() {
  ctx = new (window.AudioContext||window.webkitAudioContext)();
  reverb = buildReverb(ctx);
  masterLPF = ctx.createBiquadFilter();
  masterLPF.type='lowpass'; masterLPF.frequency.value=5500; masterLPF.Q.value=0.4;
  // Slowly breathe the master filter
  masterLPF.frequency.setValueAtTime(5500,ctx.currentTime);
  masterLPF.frequency.linearRampToValueAtTime(3800,ctx.currentTime+90);
  masterLPF.frequency.linearRampToValueAtTime(5000,ctx.currentTime+180);
  masterLPF.connect(ctx.destination);
  reverb.connect(ctx.destination);

  nextNoteT = ctx.currentTime+0.8;
  breathPhase='building'; pieceDensity=1.0;
  scheduleMain();
  scheduleChordBloom();
  schedulePolyrhythm();
  updateBreathPhase();
  addTimer(()=>{ if(playing&&ctx) playOceanSwell(ctx); }, rand(6000,14000));
  scheduleOceanSwell();
}

function stopMusic() {
  clearTimers();
  if(ctx){ctx.close();ctx=null;}
  recentNotes=[]; noteHistory=[]; lastNote=null;
  noteDisp.textContent=''; noteDisp.classList.remove('visible');
}

const btn=document.getElementById('playBtn');
btn.addEventListener('click',()=>{
  playing=!playing;
  if(playing){
    startMusic();
    document.getElementById('btnIcon').outerHTML=`<svg id="btnIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#c8a97a" stroke-width="2.2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>`;
    document.getElementById('hint').style.opacity='0';
  } else {
    stopMusic();
    document.getElementById('btnIcon').outerHTML=`<svg id="btnIcon" width="22" height="22" viewBox="0 0 24 24" fill="#c8a97a"><polygon points="5,3 19,12 5,21"/></svg>`;
  }
});

// ── Canvas ────────────────────────────────────────────────────────────────────
const canvas=document.getElementById('c'), g=canvas.getContext('2d');
let W,H;
const resize=()=>{W=canvas.width=window.innerWidth;H=canvas.height=window.innerHeight;};
resize(); window.addEventListener('resize',resize);

const particles=Array.from({length:70},()=>({
  x:Math.random(),y:Math.random(),size:rand(0.4,2.2),
  speed:rand(0.00006,0.00022),angle:rand(0,Math.PI*2),
  opacity:rand(0.03,0.11),drift:rand(-0.0002,0.0002)
}));
const threads=Array.from({length:10},()=>({
  x:Math.random(),y:rand(0.1,0.9),len:rand(0.06,0.20),
  speed:rand(0.00003,0.00008),opacity:rand(0.02,0.055),angle:rand(-0.12,0.12)
}));

let pulses=[], chordBloom=false;
function triggerPulse(rev=false){
  pulses.push({r:0,maxR:rand(90,200),opacity:rand(0.10,0.20),speed:rand(0.3,0.7),rev});
  if(coin(0.3)) pulses.push({r:0,maxR:rand(30,80),opacity:rand(0.06,0.12),speed:rand(0.6,1.2),rev:false});
}

// Chord bloom triggers large slow expanding ring
function triggerChordVisual(){
  for(let i=0;i<4;i++){
    setTimeout(()=>{
      pulses.push({r:i*15,maxR:rand(200,350),opacity:rand(0.05,0.12),speed:rand(0.15,0.35),rev:false,chord:true});
    },i*600);
  }
}

let swellAlpha=0,swellTarget=0;
setInterval(()=>{ swellTarget=swellActive?rand(0.03,0.07)*swellIntensity:0; },1500);

// Watch for chord blooms to trigger visuals
let lastChordBloom=false;
let frame=0;
function draw(){
  requestAnimationFrame(draw); frame++;
  if(chordBloom&&!lastChordBloom) triggerChordVisual();
  lastChordBloom=chordBloom;

  swellAlpha+=(swellTarget-swellAlpha)*0.003;
  g.fillStyle='rgba(26,20,16,0.15)'; g.fillRect(0,0,W,H);

  if(swellAlpha>0.003){
    const gr=g.createRadialGradient(W/2,H*0.65,0,W/2,H/2,W*0.8);
    gr.addColorStop(0,`rgba(60,95,118,${swellAlpha*2.5})`);
    gr.addColorStop(0.5,`rgba(40,70,90,${swellAlpha})`);
    gr.addColorStop(1,'transparent');
    g.fillStyle=gr; g.fillRect(0,0,W,H);
  }

  // Chord bloom ambient glow
  if(chordBloom){
    const cg=g.createRadialGradient(W/2,H/2,0,W/2,H/2,W*0.55);
    cg.addColorStop(0,`rgba(180,155,100,0.04)`);
    cg.addColorStop(1,'transparent');
    g.fillStyle=cg; g.fillRect(0,0,W,H);
  }

  for(const t of threads){
    t.x+=t.speed; if(t.x>1.2)t.x=-0.2;
    g.beginPath(); g.moveTo(t.x*W,t.y*H); g.lineTo((t.x+t.len)*W,(t.y+t.angle)*H);
    g.strokeStyle=`rgba(200,169,122,${t.opacity})`; g.lineWidth=rand(0.2,0.7); g.stroke();
  }
  for(const p of particles){
    p.angle+=p.drift; p.x+=Math.cos(p.angle)*p.speed; p.y+=Math.sin(p.angle)*p.speed*0.5;
    if(p.x<-0.05)p.x=1.05; if(p.x>1.05)p.x=-0.05;
    if(p.y<-0.05)p.y=1.05; if(p.y>1.05)p.y=-0.05;
    g.beginPath(); g.arc(p.x*W,p.y*H,p.size,0,Math.PI*2);
    g.fillStyle=`rgba(200,169,122,${p.opacity})`; g.fill();
  }
  if(frame%3===0){
    g.beginPath(); g.moveTo(rand(0,W*0.6),rand(0,H)); g.lineTo(rand(W*0.3,W),rand(0,H));
    g.strokeStyle=`rgba(200,169,122,${rand(0.006,0.025)})`; g.lineWidth=rand(0.2,0.8); g.stroke();
  }
  for(let i=pulses.length-1;i>=0;i--){
    const p=pulses[i]; p.r+=p.speed; p.opacity-=p.chord?0.0005:0.0014;
    if(p.opacity<=0||p.r>p.maxR){pulses.splice(i,1);continue;}
    g.beginPath(); g.arc(W/2,H/2,p.r*(W/320),0,Math.PI*2);
    g.strokeStyle=p.chord
      ? `rgba(210,185,130,${p.opacity})`
      : p.rev?`rgba(138,180,200,${p.opacity})`:`rgba(200,169,122,${p.opacity})`;
    g.lineWidth=p.chord?1.5:1; g.stroke();
  }
}
draw();
</script>

</body>
</html>
