<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Afterglow</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IM+Fell+English:ital@0;1&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  :root { --cream:#f0e8d8; --warm:#c8a97a; --dark:#1a1410; }
  body {
    background:var(--dark); color:var(--cream);
    font-family:'IM Fell English',serif;
    height:100dvh; display:flex; flex-direction:column;
    align-items:center; justify-content:center;
    overflow:hidden; user-select:none;
  }

  body::after {
    content:''; position:fixed; inset:0;
    background:radial-gradient(ellipse at center,transparent 30%,rgba(0,0,0,0.78) 100%);
    pointer-events:none; z-index:9;
  }
  canvas { position:fixed; inset:0; }
  #c { z-index:1; }
  #trail-canvas { z-index:3; pointer-events:none; }

  .btn-wrap {
    position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
    z-index:20; transition:opacity 3s ease; display:flex; flex-direction:column; align-items:center;
  }
  .btn-wrap.hide { opacity:0; pointer-events:none; }
  .btn {
    width:72px; height:72px; border-radius:50%;
    border:1.5px solid rgba(200,169,122,0.4); background:transparent;
    display:flex; align-items:center; justify-content:center;
    cursor:pointer; transition:border-color 0.8s,transform 0.3s; position:relative;
  }
  .btn::before { content:''; position:absolute; inset:-8px; border-radius:50%; border:1px solid rgba(200,169,122,0.12); }
  .btn:hover { border-color:rgba(200,169,122,0.7); transform:scale(1.05); }
  .hint { font-size:0.62rem; letter-spacing:0.3em; color:var(--cream); opacity:0.22; text-transform:uppercase; margin-top:0.7rem; }

  .corner {
    position:fixed; bottom:2rem; left:2rem;
    z-index:20; display:flex; flex-direction:column; gap:0.4rem;
  }
  .title-row { display:flex; align-items:baseline; gap:0.7em; }
  .stop-btn {
    background:none; border:none; cursor:pointer; padding:0;
    font-family:'IM Fell English',serif; font-style:italic;
    font-size:clamp(0.9rem,2.5vw,1.3rem); letter-spacing:0.15em;
    color:var(--warm); opacity:0; pointer-events:none;
    transition:opacity 2s ease;
  }
  .stop-btn.visible { opacity:0.45; pointer-events:all; }
  .stop-btn:hover { opacity:0.75 !important; }
  .note-indicator { font-size:clamp(0.7rem,2vw,0.9rem); letter-spacing:0.45em; color:var(--warm); opacity:0; transition:opacity 1.4s ease; font-style:italic; min-height:1.1em; }
  .note-indicator.visible { opacity:0.55; }
  .title { font-size:clamp(0.9rem,2.5vw,1.3rem); letter-spacing:0.2em; opacity:0.55; font-weight:normal; }
</style>
</head>
<body>
<canvas id="trail-canvas"></canvas>
<canvas id="c"></canvas>

<div class="btn-wrap" id="btnWrap">
  <button class="btn" id="playBtn" aria-label="Play">
    <svg id="btnIcon" width="22" height="22" viewBox="0 0 24 24" fill="#c8a97a"><polygon points="5,3 19,12 5,21"/></svg>
  </button>
  <p class="hint" id="hint">tap to begin</p>
</div>

<div class="corner">
  <div class="note-indicator" id="noteDisp"></div>
  <div class="title-row">
    <h1 class="title">Afterglow</h1>
    <button class="stop-btn" id="stopBtn">stop</button>
  </div>
</div>

<script>

const rand = (a,b) => a + Math.random()*(b-a);
const randInt = (a,b) => Math.floor(rand(a,b+1));
const pick = arr => arr[Math.floor(Math.random()*arr.length)];
const coin = p => Math.random() < p;

const MIX = {
  G2:98.00, C3:130.81, D3:146.83, E3:164.81, F3:174.61,
  G3:196.00, A3:220.00, B3:246.94,
  C4:261.63, D4:293.66, E4:329.63, F4:349.23,
  G4:392.00, A4:440.00, B4:493.88,
  C5:523.25, D5:587.33, E5:659.26, F5:698.46,
  G5:784.00, A5:880.00, B5:987.77,
};

const MELODY = ['G4','F4','E4','C4','D4','A4','G3','C3','G5','E5','C5','B5','A5'];
const CORE   = ['G4','F4','E4','C4'];
const COLOUR = ['D4','A4'];
const LOW    = ['G3','C3'];          // rare low notes — anchor moments
const HIGH   = ['G5','E5','C5','B5']; // rare high notes — bright peaks

const TRANSITIONS = {
  // Octave 4 core — unchanged voice leading rules
  G4: { A4:5, F4:2, E4:2, C4:2, D4:1, G5:1, G3:1 },
  F4: { E4:3, C4:3, G4:2, D4:2, A4:1, E5:1 },
  E4: { C4:3, G4:3, F4:2, A4:2, D4:0, E5:1, C5:1 },
  C4: { G4:3, E4:3, F4:2, D4:2, A4:1, C5:1, C3:1 },
  D4: { E4:6, G4:2, F4:1, C4:1, A4:1 },
  A4: { E4:3, F4:3, C4:2, D4:2, G4:0 },
  // Low octave — resolve back up naturally
  G3: { G4:4, C4:3, E4:2, F4:1 },
  C3: { G4:4, C4:3, E4:2, G3:1 },
  // High octave — resolve back down naturally
  G5: { G4:4, E4:3, F4:2, C4:1 },
  E5: { C4:3, G4:3, E4:2, F4:2 },
  C5: { G4:4, E4:3, C4:2, F4:1 },
  B5: { A5:10 },                   // B5 always resolves to A5 — no exceptions
  A5: { G4:4, E4:3, G5:2, F4:1 }, // A5 then resolves back down
};

// ── D Dorian transition table ─────────────────────────────────────────────────
// Same notes as G Mixolydian — different gravity. D is home, A is the fifth.
// Key Dorian signatures: E→D allowed (was forbidden), C→D strong, A→D strong
const TRANSITIONS_DORIAN = {
  D4: { E4:1, C4:5, A4:5, F4:2, G4:1, D3:2 }, // D is home — approached from many angles
  A4: { D4:6, E4:3, C4:2, G4:1, A3:2 },        // A (fifth) falls to D
  E4: { D4:5, C4:3, A4:2, F4:1 },              // E→D now allowed — the Dorian move
  C4: { D4:6, E4:3, A4:2, G4:1 },              // C (minor 7th) resolves up to D
  G4: { A4:3, F4:3, E4:2, D4:2 },              // G less stable — drifts toward D
  F4: { E4:4, D4:3, G4:2, A4:1 },              // F resolves down through E to D
  // Low
  D3: { D4:5, A4:3, E4:2 },
  A3: { D4:4, A4:4, E4:2 },
  // High
  D5: { A4:4, E4:3, C4:2, G4:1 },
  A5: { D4:3, E4:3, G4:2, G5:1 },
  E5: { D4:3, C4:3, A4:2, F4:2 },
  G5: { A4:3, E4:3, D4:2, F4:2 },
  B5: { A5:10 },
  C5: { D4:3, E4:3, A4:2, G4:1 },
  G3: { D4:4, A4:3, E4:2 },
  C3: { D4:4, A4:3, E4:2 },
};

// ── Modal phase state ─────────────────────────────────────────────────────────
let modalPhase = 'mixolydian';   // 'mixolydian' | 'dorian'
let modalBlend = 0;              // 0 = pure mixolydian, 1 = pure dorian
let modalTarget = 0;             // what modalBlend lerps toward
let notesInCurrentMode = 0;      // count notes played since last shift
let nextModalShift = Math.floor(rand(18, 35)); // notes before first shift

function updateModalBlend() {
  // Smooth lerp — takes ~12 notes to fully shift
  modalBlend += (modalTarget - modalBlend) * 0.08;
}

function considerModalShift() {
  notesInCurrentMode++;
  if(notesInCurrentMode < nextModalShift) return;
  notesInCurrentMode = 0;

  if(modalPhase === 'mixolydian') {
    // Shift to Dorian — preferably during 'building' or 'full' phases
    if(breathPhase !== 'silence') {
      modalPhase = 'dorian';
      modalTarget = 1;
      nextModalShift = Math.floor(rand(16, 32)); // stay in Dorian for 16-32 notes
    }
  } else {
    // Return to Mixolydian — F natural is the pivot note back home
    modalPhase = 'mixolydian';
    modalTarget = 0;
    nextModalShift = Math.floor(rand(22, 45)); // stay in Mixolydian longer
  }
}

const VOICINGS = {
  G4: ['G2','D3','G3','B3','D4','G4','B4','D5'],
  F4: ['C3','F3','A3','C4','F4','A4','C5','E5'],
  E4: ['G2','E3','B3','E4','G4','B4','E5'],
  C4: ['G2','C3','G3','C4','E4','G4','C5'],
  D4: ['D3','A3','D4','F4','A4','D5'],
  A4: ['A2','E3','A3','C4','E4','A4','C5'],
  GF: ['G2','F3','C4','F4','A4','C5','F5'],
  GE: ['G2','E3','B3','G4','B4','E5'],
  GC: ['G2','C3','G3','C4','E4','G4','D5'],
  FE: ['C3','E3','A3','C4','F4','A4','C5'],
  FC: ['F3','C4','F4','A4','C5','F5'],
  EC: ['C3','E3','G3','C4','E4','G4','B4'],
  DA: ['D3','A3','D4','E4','A4','D5'],
  GA: ['G2','A3','E4','G4','A4','E5'],
  ALL:['G2','A2','C3','E3','G3','B3','D4','F4','G4','A4','C5'],
};

let ctx, reverb, masterLPF, playing=false, lastNote=null;
let timers=[];
const addTimer=(fn,ms)=>{const t=setTimeout(fn,ms);timers.push(t);return t;};
const clearTimers=()=>{timers.forEach(clearTimeout);timers=[];};

let recentNotes = [];
let noteHistory = [];
let breathPhase = 'building';
let pieceDensity = 1.0;
let swellActive=false, swellIntensity=0;
let nextNoteT=0;

function buildReverb(actx) {
  const sr=actx.sampleRate, dur=5.0, decay=4.0;
  const len=Math.floor(sr*dur);
  const ir=actx.createBuffer(2,len,sr);
  for (let ch=0;ch<2;ch++) {
    const d=ir.getChannelData(ch);
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0;
    for (let i=0;i<len;i++) {
      const w=Math.random()*2-1;
      b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759;
      b2=0.96900*b2+w*0.1538520; b3=0.86650*b3+w*0.3104856;
      b4=0.55000*b4+w*0.5329522; b5=-0.7616*b5-w*0.0168980;
      d[i]=(b0+b1+b2+b3+b4+b5+w*0.5362)*0.11*Math.pow(1-i/len,decay);
    }
  }
  const conv=actx.createConvolver(); conv.buffer=ir; return conv;
}

function makePink(actx,dur) {
  const sr=actx.sampleRate;
  const buf=actx.createBuffer(2,Math.floor(sr*dur),sr);
  for (let ch=0;ch<2;ch++) {
    const d=buf.getChannelData(ch);
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
    for (let i=0;i<d.length;i++) {
      const w=Math.random()*2-1;
      b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759;
      b2=0.96900*b2+w*0.1538520; b3=0.86650*b3+w*0.3104856;
      b4=0.55000*b4+w*0.5329522; b5=-0.7616*b5-w*0.0168980;
      d[i]=(b0+b1+b2+b3+b4+b5+b6+w*0.5362)*0.11; b6=w*0.115926;
    }
  }
  return buf;
}

function tapeCurve(amt=35) {
  const n=256,c=new Float32Array(n);
  for (let i=0;i<n;i++){const x=i*2/n-1;c[i]=(Math.PI+amt)*x/(Math.PI+amt*Math.abs(x));}
  return c;
}

function playNote(actx, freqHz, time, opts={}) {
  const {
    vol=rand(0.10,0.16), decay=rand(4.0,7.0),
    reversed=false, quiet=false, dryWet=0.62,
    wobble=rand(0.997,1.003),
    pan=0,           // -1 (full left) to 1 (full right), 0 = centre
    pannerRef=null,  // if provided, store the panner node here for live updates
  } = opts;
  const f0=freqHz*wobble;
  const v=quiet?vol*0.4:vol;

  // Stereo panner — sits at the very top of the chain before dry/wet split
  // Both dry and reverb send are panned: dry fully, reverb send at 50% intensity
  // This gives clear stereo placement while keeping reverb tail spacious
  const panner = actx.createStereoPanner();
  panner.pan.value = Math.max(-1, Math.min(1, pan));
  panner.connect(masterLPF);
  if(pannerRef) pannerRef.node = panner; // expose for live position updates

  // Reverb send panner — half the pan amount so reverb stays somewhat wide
  const reverbPanner = actx.createStereoPanner();
  reverbPanner.pan.value = Math.max(-1, Math.min(1, pan * 0.5));
  reverbPanner.connect(reverb);

  const dryG=actx.createGain(); dryG.gain.value=v*(1-dryWet);
  const wetG=actx.createGain(); wetG.gain.value=v*dryWet;
  dryG.connect(panner);       // dry: fully panned
  wetG.connect(reverbPanner); // wet: half-panned — reverb stays wide but placed
  const preLPF=actx.createBiquadFilter(); preLPF.type='lowpass';
  preLPF.frequency.value=rand(1800,2600); preLPF.Q.value=0.5;
  preLPF.connect(dryG); preLPF.connect(wetG);
  const warmth=actx.createBiquadFilter(); warmth.type='highshelf';
  warmth.frequency.value=4000; warmth.gain.value=rand(-5,-9);
  warmth.connect(preLPF);
  const shaper=actx.createWaveShaper();
  shaper.curve=tapeCurve(rand(20,45)); shaper.oversample='4x';
  shaper.connect(warmth);
  const env=actx.createGain();
  if (reversed) {
    env.gain.setValueAtTime(0.001,time);
    env.gain.exponentialRampToValueAtTime(1.0,time+decay*0.82);
    env.gain.linearRampToValueAtTime(0,time+decay);
  } else {
    env.gain.setValueAtTime(0,time);
    env.gain.linearRampToValueAtTime(1.0,time+0.010);
    env.gain.exponentialRampToValueAtTime(0.38,time+0.15);
    env.gain.exponentialRampToValueAtTime(0.001,time+decay);
  }
  env.connect(shaper);
  const ih=1.0006;
  [
    {m:1.000,      g:1.00,d:1.00},
    {m:2.000*ih,   g:0.48,d:0.55},
    {m:3.000*ih*ih,g:0.22,d:0.35},
    {m:4*Math.pow(ih,3),g:0.12,d:0.22},
    {m:5*Math.pow(ih,4),g:0.06,d:0.15},
    {m:6*Math.pow(ih,5),g:0.03,d:0.10},
  ].forEach(p=>{
    const osc=actx.createOscillator(); osc.type='sine'; osc.frequency.value=f0*p.m;
    if(p.m<1.1){
      const wow=actx.createOscillator(); wow.frequency.value=rand(0.3,0.8);
      const wg=actx.createGain(); wg.gain.value=rand(0.5,1.5);
      wow.connect(wg); wg.connect(osc.frequency);
      wow.start(time); wow.stop(time+decay+2);
    }
    const pg=actx.createGain();
    pg.gain.setValueAtTime(p.g,time);
    pg.gain.exponentialRampToValueAtTime(0.001,time+decay*p.d);
    osc.connect(pg); pg.connect(env);
    osc.start(time); osc.stop(time+decay+2.1);
  });
  if (!reversed) {
    const hLen=Math.floor(actx.sampleRate*0.035);
    const hb=actx.createBuffer(1,hLen,actx.sampleRate);
    const hd=hb.getChannelData(0);
    for(let i=0;i<hLen;i++) hd[i]=(Math.random()*2-1)*Math.exp(-i/350)*0.6;
    const hs=actx.createBufferSource(); hs.buffer=hb;
    const hbp=actx.createBiquadFilter(); hbp.type='bandpass';
    hbp.frequency.value=rand(600,1100); hbp.Q.value=2;
    const hg=actx.createGain(); hg.gain.value=rand(0.08,0.15);
    const hFade=actx.createGain(); hFade.gain.setValueAtTime(1,time+0.03); hFade.gain.linearRampToValueAtTime(0,time+0.045);
    hs.connect(hbp); hbp.connect(hg); hg.connect(hFade); hFade.connect(wetG);
    hs.start(time); hs.stop(time+0.05);
  }
}

function bloomChord(actx) {
  if (!playing || !ctx) return;
  const unique = [...new Set(recentNotes.slice(-6))];
  let voicingKey = 'G4';
  if (unique.length >= 5) { voicingKey = 'ALL'; }
  else if (unique.length >= 4 && unique.includes('G4') && unique.includes('A4')) { voicingKey = 'ALL'; }
  else if (unique.includes('D4') && unique.includes('A4')) { voicingKey = 'DA'; }
  else if (unique.includes('G4') && unique.includes('A4')) { voicingKey = 'GA'; }
  else if (unique.includes('D4')) { voicingKey = 'D4'; }
  else if (unique.includes('A4')) { voicingKey = 'A4'; }
  else if (unique.length >= 4) { voicingKey = 'ALL'; }
  else if (unique.length === 3) {
    voicingKey = unique.includes('G4') && unique.includes('F4') ? 'GF'
               : unique.includes('G4') && unique.includes('E4') ? 'GE'
               : unique.includes('G4') && unique.includes('C4') ? 'GC'
               : unique.includes('F4') && unique.includes('E4') ? 'FE'
               : unique.includes('F4') && unique.includes('C4') ? 'FC' : 'EC';
  } else if (unique.length === 2) {
    if      (unique.includes('G4') && unique.includes('F4')) voicingKey='GF';
    else if (unique.includes('G4') && unique.includes('E4')) voicingKey='GE';
    else if (unique.includes('G4') && unique.includes('C4')) voicingKey='GC';
    else if (unique.includes('F4') && unique.includes('E4')) voicingKey='FE';
    else if (unique.includes('F4') && unique.includes('C4')) voicingKey='FC';
    else if (unique.includes('D4') && unique.includes('A4')) voicingKey='DA';
    else if (unique.includes('G4') && unique.includes('A4')) voicingKey='GA';
    else voicingKey='EC';
  } else if (unique.length === 1) { voicingKey = unique[0]; }

  const notes = VOICINGS[voicingKey] || VOICINGS['G4'];
  const chordDur = rand(8, 16);
  const fadeIn   = rand(2.5, 5);
  const now = actx.currentTime;
  const chordMaster = actx.createGain();
  chordMaster.gain.setValueAtTime(0, now);
  chordMaster.gain.linearRampToValueAtTime(rand(0.06,0.12), now+fadeIn);
  chordMaster.gain.setValueAtTime(rand(0.06,0.12), now+chordDur*0.6);
  chordMaster.gain.linearRampToValueAtTime(0, now+chordDur);
  const chordWet = actx.createGain(); chordWet.gain.value=0.85;
  const chordDry = actx.createGain(); chordDry.gain.value=0.15;
  chordMaster.connect(chordWet); chordWet.connect(reverb);
  chordMaster.connect(chordDry); chordDry.connect(masterLPF);
  const chordLPF = actx.createBiquadFilter();
  chordLPF.type='lowpass'; chordLPF.frequency.value=rand(900,1400); chordLPF.Q.value=0.3;
  chordLPF.connect(chordMaster);
  notes.forEach((noteName, i) => {
    const f = MIX[noteName]; if (!f) return;
    const stagger = i * rand(0.15, 0.4);
    const osc1=actx.createOscillator(); osc1.type='sine'; osc1.frequency.value=f*rand(0.998,1.002);
    const osc2=actx.createOscillator(); osc2.type='sine'; osc2.frequency.value=f*2.001;
    const osc3=actx.createOscillator(); osc3.type='sine'; osc3.frequency.value=f*3.002;
    const og=actx.createGain();
    og.gain.setValueAtTime(0, now+stagger);
    og.gain.linearRampToValueAtTime(1.0/(notes.length*0.7), now+stagger+rand(1,2.5));
    og.gain.setValueAtTime(1.0/(notes.length*0.7), now+chordDur*0.55);
    og.gain.linearRampToValueAtTime(0, now+chordDur-stagger);
    const h2g=actx.createGain(); h2g.gain.value=0.18;
    const h3g=actx.createGain(); h3g.gain.value=0.07;
    osc1.connect(og); og.connect(chordLPF);
    osc2.connect(h2g); h2g.connect(chordLPF);
    osc3.connect(h3g); h3g.connect(chordLPF);
    const end=now+chordDur+2;
    [osc1,osc2,osc3].forEach(o=>{o.start(now+stagger);o.stop(end);});
  });
  chordBloom=true;
  setTimeout(()=>{ chordBloom=false; }, chordDur*1000*0.7);
}

function playOceanSwell(actx) {
  const dur=rand(16,28);
  const buf=makePink(actx,dur);
  const src=actx.createBufferSource(); src.buffer=buf;
  const peak=rand(0.13,0.20);
  const env=actx.createGain();
  env.gain.setValueAtTime(0,actx.currentTime);
  env.gain.linearRampToValueAtTime(peak,actx.currentTime+dur*0.30);
  env.gain.setValueAtTime(peak,actx.currentTime+dur*0.62);
  env.gain.linearRampToValueAtTime(0.0001,actx.currentTime+dur);
  env.gain.linearRampToValueAtTime(0,actx.currentTime+dur+0.1);
  const lpf=actx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=rand(350,550); lpf.Q.value=0.7;
  const body=actx.createBiquadFilter(); body.type='peaking'; body.frequency.value=rand(80,150); body.Q.value=0.5; body.gain.value=rand(4,8);
  const lfo=actx.createOscillator(); lfo.frequency.value=rand(0.03,0.09);
  const lfg=actx.createGain(); lfg.gain.value=rand(0.015,0.04);
  lfo.connect(lfg); lfg.connect(env.gain);
  const sd=actx.createGain(); sd.gain.value=0.55;
  const sw=actx.createGain(); sw.gain.value=0.5;
  src.connect(body); body.connect(lpf); lpf.connect(env);
  env.connect(sd); sd.connect(masterLPF);
  env.connect(sw); sw.connect(reverb);
  lfo.start(); lfo.stop(actx.currentTime+dur);
  src.start(); src.stop(actx.currentTime+dur);
  swellActive=true; swellIntensity=peak/0.20;
  setTimeout(()=>{swellActive=false;swellIntensity=0;},dur*1000);
}

function playPolyLayer(actx, ratio, pulseLen, startT) {
  const step=(pulseLen*4)/ratio;
  for(let i=0;i<ratio;i++){
    const name=pick(MELODY); const f=MIX[name];
    playNote(actx,f,startT+i*step,{vol:rand(0.07,0.11),decay:rand(2.0,3.5),quiet:false,dryWet:0.72});
  }
}

function updateBreathPhase() {
  const phases = ['building','full','withdrawing','silence'];
  const durations = {
    building:  rand(45000,90000), full: rand(30000,60000),
    withdrawing: rand(40000,70000), silence: rand(15000,35000),
  };
  const densities = { building:1.0, full:0.85, withdrawing:1.4, silence:2.8 };
  const next = (current) => { const idx=phases.indexOf(current); return phases[(idx+1)%phases.length]; };
  const transition = () => {
    if (!playing) return;
    breathPhase = next(breathPhase);
    pieceDensity = densities[breathPhase];
    addTimer(transition, durations[breathPhase]);
  };
  addTimer(transition, durations[breathPhase]);
}

function pickMelodyNote() {
  updateModalBlend();
  considerModalShift();

  let pool = [];
  if (lastNote) {
    // Blend between Mixolydian and Dorian transition tables
    const tMix = TRANSITIONS[lastNote] || {};
    const tDor = TRANSITIONS_DORIAN[lastNote] || {};
    // Collect all possible target notes from both tables
    const allNotes = new Set([...Object.keys(tMix), ...Object.keys(tDor)]);
    for(const note of allNotes){
      const wMix = (tMix[note] || 0) * (1 - modalBlend);
      const wDor = (tDor[note] || 0) * modalBlend;
      const w = Math.round(wMix + wDor);
      for(let i=0; i<w; i++) pool.push(note);
    }
  }
  if(pool.length === 0){
    // Fallback — weight toward current tonal center
    const center = modalBlend > 0.5 ? ['D4','A4','E4','C4'] : ['G4','F4','E4','C4'];
    for (const n of center) { pool.push(n,n,n); }
    for (const n of LOW)    { pool.push(n); }
    for (const n of HIGH)   { pool.push(n); }
  }
  if (noteHistory.length > 16 && coin(0.22) && lastNote) {
    const lookback = Math.floor(rand(4,9));
    const ghost = noteHistory[noteHistory.length - lookback];
    const allowed = TRANSITIONS[lastNote] || {};
    if (ghost && (allowed[ghost] || 0) > 0) { pool.push(ghost, ghost); }
  }
  const filtered = pool.filter(n => n !== lastNote);
  const chosen = filtered.length > 0 ? pick(filtered) : pick(pool);
  lastNote = chosen;
  noteHistory.push(chosen);
  recentNotes.push(chosen);
  if (recentNotes.length > 8) recentNotes.shift();
  if (noteHistory.length > 200) noteHistory.shift();
  return chosen;
}

const noteDisp=document.getElementById('noteDisp');

function scheduleMain() {
  if (!playing||!ctx) return;
  const name = pickMelodyNote();
  const f = MIX[name];
  const isRev = coin(0.12);
  const baseGap = rand(2.8,6.2);
  const gap = baseGap * pieceDensity;
  const noteVol = rand(0.04, 0.22); // wider velocity range — pp to mf
  const noteDecay = rand(4.0,7.0);
  nextNoteT += gap;
  // Spawn orb first to get its position, then play note panned to that position
  const ms = Math.max(0,(nextNoteT-ctx.currentTime)*1000);
  addTimer(()=>{
    if(!playing) return;
    // Y position from pitch, X random, velocity drives opacity+color vibrancy
    const pitchY = PITCH_Y[name] !== undefined ? PITCH_Y[name] : 0.5;
    const spawnY = pitchY + rand(-0.04, 0.04); // tiny variation around pitch lane
    const orb = spawnButterfly({vol:noteVol, decay:noteDecay, rev:isRev, spawnY, velocity:noteVol});
    if(orb && ctx) {
      const pan = (orb.x * 2) - 1;
      playNote(ctx, f, ctx.currentTime+0.05, {
        reversed:isRev, dryWet:0.62, vol:noteVol, decay:noteDecay,
        pan, pannerRef: orb.pannerRef
      });
    }
  }, ms);
  addTimer(scheduleMain,(gap-1.4)*1000);
}

function scheduleChordBloom() {
  if(!playing||!ctx) return;
  const wait = rand(12000,22000);
  addTimer(()=>{
    if(!playing||!ctx) return;
    if([...new Set(recentNotes)].length >= 4) bloomChord(ctx);
    scheduleChordBloom();
  }, wait);
}

function schedulePolyrhythm() {
  if(!playing||!ctx) return;
  addTimer(()=>{
    if(!playing||!ctx) return;
    if(breathPhase !== 'silence') {
      const ratio=coin(0.5)?5:6, pulse=rand(1.0,1.7);
      const t0=ctx.currentTime+0.5;
      playPolyLayer(ctx,ratio,pulse,t0);
      playPolyLayer(ctx,ratio,pulse,t0+pulse*4+rand(0.5,1.5));
      for(let pi=0;pi<ratio;pi++) setTimeout(triggerPolyOrb, pi*(pulse*4/ratio)*1000);
    }
    schedulePolyrhythm();
  }, rand(20000,45000));
}

function scheduleOceanSwell() {
  if(!playing||!ctx) return;
  addTimer(()=>{
    if(!playing||!ctx) return;
    if(!swellActive) playOceanSwell(ctx);
    scheduleOceanSwell();
  }, rand(18000,40000));
}

function startMusic() {
  ctx = new (window.AudioContext||window.webkitAudioContext)();
  reverb = buildReverb(ctx);
  const limiter = ctx.createDynamicsCompressor();
  limiter.threshold.value=-3; limiter.knee.value=0; limiter.ratio.value=20;
  limiter.attack.value=0.001; limiter.release.value=0.1;
  limiter.connect(ctx.destination);
  const compressor = ctx.createDynamicsCompressor();
  compressor.threshold.value=-18; compressor.knee.value=10; compressor.ratio.value=3;
  compressor.attack.value=0.02; compressor.release.value=0.4;
  compressor.connect(limiter);
  const masterGain = ctx.createGain(); masterGain.gain.value=0.7;
  masterGain.connect(compressor);
  masterLPF = ctx.createBiquadFilter();
  masterLPF.type='lowpass'; masterLPF.frequency.value=5500; masterLPF.Q.value=0.4;
  masterLPF.frequency.setValueAtTime(5500,ctx.currentTime);
  masterLPF.frequency.linearRampToValueAtTime(3800,ctx.currentTime+90);
  masterLPF.frequency.linearRampToValueAtTime(5000,ctx.currentTime+180);
  masterLPF.connect(masterGain);
  reverb.connect(masterGain);
  nextNoteT = ctx.currentTime+0.8;
  breathPhase='building'; pieceDensity=1.0;
  pieceStartTime = Date.now();
  scheduleMain(); scheduleChordBloom(); schedulePolyrhythm(); updateBreathPhase();
  addTimer(()=>{ if(playing&&ctx) playOceanSwell(ctx); }, rand(6000,14000));
  scheduleOceanSwell();
}

function stopMusic() {
  clearTimers();
  if(ctx){ctx.close();ctx=null;}
  recentNotes=[]; noteHistory=[]; lastNote=null;
  noteDisp.textContent=''; noteDisp.classList.remove('visible');
}

const btn=document.getElementById('playBtn');
const btnWrap=document.getElementById('btnWrap');
const stopBtn=document.getElementById('stopBtn');
let btnHideTimer=null;

stopBtn.addEventListener('click',()=>{
  playing=false; stopMusic(); stopBtn.classList.remove('visible');
  butterflies.length=0; btnWrap.style.display='flex'; btnWrap.style.opacity='1';
  document.getElementById('btnIcon').outerHTML=`<svg id="btnIcon" width="22" height="22" viewBox="0 0 24 24" fill="#c8a97a"><polygon points="5,3 19,12 5,21"/></svg>`;
  document.getElementById('hint').style.opacity='0.22';
});

btn.addEventListener('click',()=>{
  playing=!playing;
  if(playing){
    startMusic();
    document.getElementById('btnIcon').outerHTML=`<svg id="btnIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#c8a97a" stroke-width="2.2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>`;
    document.getElementById('hint').style.opacity='0';
    btnHideTimer = setTimeout(()=>{ btnWrap.style.display='none'; }, 2000);
    setTimeout(()=>{ if(playing) document.getElementById('stopBtn').classList.add('visible'); }, 20000);
  } else {
    stopMusic(); clearTimeout(btnHideTimer); btnWrap.classList.remove('hide');
    document.getElementById('btnIcon').outerHTML=`<svg id="btnIcon" width="22" height="22" viewBox="0 0 24 24" fill="#c8a97a"><polygon points="5,3 19,12 5,21"/></svg>`;
  }
});

// ── Canvas ────────────────────────────────────────────────────────────────────
const trailCanvas=document.getElementById('trail-canvas'), tg=trailCanvas.getContext('2d');
const canvas=document.getElementById('c'), g=canvas.getContext('2d');
let W,H;
const resize=()=>{
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;      canvas.height = H * dpr;
  trailCanvas.width = W * dpr; trailCanvas.height = H * dpr;
  canvas.style.width = W + 'px';      canvas.style.height = H + 'px';
  trailCanvas.style.width = W + 'px'; trailCanvas.style.height = H + 'px';
  // Scale context so drawing coords stay in CSS pixels
  g.scale(dpr, dpr);
  tg.scale(dpr, dpr);
};
resize(); window.addEventListener('resize',resize);

let pieceAge=0, pieceStartTime=null;
let hueShift=0, hueTarget=0;

const WHEEL = [
  {r:248,g:195,b: 95},
  {r:252,g:220,b:110},
  {r:245,g:168,b:105},
  {r:238,g:128,b:138},
  {r:210,g:115,b:175},
  {r:165,g:128,b:215},
  {r:118,g:145,b:225},
  {r:105,g:175,b:210},
  {r:248,g:195,b: 95},
];

function wheelRGB(hue) {
  const h = ((hue % 1.0) + 1.0) % 1.0;
  const seg = h * (WHEEL.length-1);
  const i = Math.min(Math.floor(seg), WHEEL.length-2);
  const s = seg - i;
  const a=WHEEL[i], b2=WHEEL[i+1];
  return [Math.round(a.r+(b2.r-a.r)*s), Math.round(a.g+(b2.g-a.g)*s), Math.round(a.b+(b2.b-a.b)*s)];
}

function duskRGB(bias, age) {
  const baseHue = hueShift + bias * 0.28;
  const [r,gv,bv] = wheelRGB(baseHue);
  return [Math.max(0,Math.min(255,r)), Math.max(0,Math.min(255,gv)), Math.max(0,Math.min(255,bv))];
}
function dc(bias, opacity, age){ const [r,gv,b]=duskRGB(bias,age); return `rgba(${r},${gv},${b},${Math.min(Math.max(opacity,0),0.99)})`; }



const washes = Array.from({length:9},(_,wi)=>({
  x:rand(0.0,1.0), y:rand(0.0,1.0),
  vx:rand(-0.00004,0.00004), vy:rand(-0.00003,0.00003),
  r:rand(0.75,1.2),
  bias: wi/9,
  biasDrift: rand(-0.0003,0.0003),
  opacity:rand(0.012,0.025),
  opacityActual:0,
  phase:rand(0,Math.PI*2),
  phaseSpeed:rand(0.0002,0.0006)
}));


// ── Pitch → Y position mapping ────────────────────────────────────────────────
// Lower notes appear lower on screen, higher notes appear higher
// Maps each note name to a normalised Y position (0=top, 1=bottom)
const PITCH_Y = {
  G2:0.92, C3:0.86, G3:0.80, A3:0.76,
  C4:0.70, D4:0.65, E4:0.60, F4:0.55,
  G4:0.50, A4:0.44, B4:0.38,
  C5:0.33, D5:0.28, E5:0.23, F5:0.19,
  G5:0.14, A5:0.10, B5:0.06,
};

let butterflies=[];

function spawnButterfly(opts={}) {
  const {vol=rand(0.10,0.15), decay=rand(4,7), rev=false,
         spawnY=rand(0.15,0.85), velocity=0.13}=opts;
  const baseSize = rand(10,18)*(0.7+vol*1.0);
  const pannerRef = {node: null};
  const velNorm = Math.max(0, Math.min(1, (velocity - 0.04) / 0.18));
  const velOpacity = 0.15 + velNorm * 0.60;
  const velVibrancy = 0.3 + velNorm * 0.7;
  butterflies.push({
    x: rand(0.08, 0.92), y: spawnY,
    speed: rand(0.00006, 0.00045),  // wide range — some drift, some zip
    angle: rand(0, Math.PI*2),
    angleV: rand(-0.00004, 0.00004),
    angleV2: rand(-0.000004, 0.000004),
    sinX:0, sinXSpeed:0, sinXAmp:0, sinY:0, sinYSpeed:0, sinYAmp:0,
    size: baseSize, opacity: 0,
    targetOpacity: velOpacity,
    vibrancy: velVibrancy,
    // velocity drives max opacity
    vibrancy: velVibrancy,            // velocity drives color vibrancy
    life: 1.0, decay: 0.00012 + (1/decay)*0.0001,
    rev, bias: rev ? rand(0.55,0.95) : rand(0.05,0.55),
    age: pieceAge, trail: [], trailMax: 280, mergeCount: 0,
    pannerRef,  // live stereo position reference
  });
  return butterflies[butterflies.length-1];
}

function spawnOrbAt(x, y, angle, opts={}) {
  const {vol=rand(0.10,0.15), decay=rand(4,7), rev=false, linkedAngleRef=null}=opts;
  const baseSize = rand(4,8);
  const orb = {
    x, y, speed: rand(0.00006, 0.00045), angle,
    angleV: rand(-0.00004, 0.00004), angleV2: rand(-0.000004, 0.000004),
    sinX:0, sinXSpeed:0, sinXAmp:0, sinY:0, sinYSpeed:0, sinYAmp:0,
    size: baseSize, opacity: 0, targetOpacity: rand(0.28, 0.55),
    life: 1.0, decay: 0.00012 + (1/decay)*0.0001,
    rev, bias: rev ? rand(0.55,0.95) : rand(0.05,0.55),
    age: pieceAge, trail: [], trailMax: 280, mergeCount: 0,
    linkedAngleRef, linkedUntil: linkedAngleRef ? (Date.now()/1000 + 10) : 0,
    pannerRef: {node: null},
  };
  butterflies.push(orb); return orb;
}

let pulses=[], chordBloom=false;

function triggerPulse(rev=false, vol=0.13, decay=5){
  const orb = spawnButterfly({vol, decay, rev});
  if(orb && ctx) {
    // Pan = orb x position mapped to -1..1, played at next scheduled time
    const pan = (orb.x * 2) - 1;
    orb.pannerRef.pan = pan; // store initial pan
  }
}
function triggerPolyOrb(){ spawnButterfly({vol:rand(0.05,0.08), decay:rand(2,4), rev:false}); }

function triggerChordVisual(){
  chordBloomAlpha = 0.06;
  const sharedAngle = rand(0, Math.PI*2);
  const cx = rand(0.25, 0.75), cy = rand(0.25, 0.75);
  const angleRef = {angle: sharedAngle};
  const spread = 0.04;
  for(let i=0;i<3;i++){
    const ox = cx + (i-1)*spread*Math.cos(sharedAngle + Math.PI*0.5);
    const oy = cy + (i-1)*spread*Math.sin(sharedAngle + Math.PI*0.5);
    spawnOrbAt(ox, oy, sharedAngle, {vol:rand(0.07,0.11), decay:rand(8,14), rev:false, linkedAngleRef: angleRef});
  }
}

let swellAlpha=0, swellTarget=0, chordBloomAlpha=0, swellErase=0;
setInterval(()=>{ swellTarget=swellActive?rand(0.025,0.055)*swellIntensity:0; },1500);

let lastChordBloom=false, frame=0;

// ── Projector artifacts ───────────────────────────────────────────────────────
let flickerIntensity = 0;      // 0-1, drives brightness flash
let flickerDecay = 0;


function draw(){
  requestAnimationFrame(draw); frame++;

  // Before playing — clear all three canvases, show nothing
  if(!playing){
    g.clearRect(0,0,W,H);
    tg.clearRect(0,0,W,H);
    g.fillStyle='rgba(252,248,240,1)'; g.fillRect(0,0,W,H);
    return;
  }

  if(chordBloom&&!lastChordBloom) triggerChordVisual();
  lastChordBloom=chordBloom;
  if(pieceStartTime) pieceAge=(Date.now()-pieceStartTime)/1000;
  hueShift += 0.000035;
  if(swellAlpha > 0.01){
    const swellHue = 0.62 + Math.sin(pieceAge*0.08)*0.08;
    hueShift += (swellHue - ((hueShift%1+1)%1)) * swellAlpha * 0.008;
  }
  swellAlpha += (swellTarget-swellAlpha)*0.003;
  chordBloomAlpha *= 0.985;

  const t = Math.min(pieceAge/320,1);
  const bgR=Math.round(255-t*8), bgG=Math.round(250-t*10), bgB=Math.round(242-t*6);

  if(swellActive){ swellErase += (Math.min(swellIntensity*0.85,0.92)-swellErase)*0.003; }
  else           { swellErase += (0-swellErase)*0.001; }

  const baseFade = breathPhase==='silence'?0.0014:0.0003;
  // Density regulator — count total trail length, increase erase when too dense
  // This keeps the canvas at the sparse Japanese line-drawing quality
  const totalTrailPts = butterflies.reduce((s,b) => s + b.trail.length, 0);
  const densityPressure = Math.max(0, (totalTrailPts - 800) / 2000); // kicks in above 800pts
  const trailFade = baseFade + swellErase*0.016 + densityPressure*0.004;
  if(frame%2===0){ tg.fillStyle=`rgba(${bgR},${bgG},${bgB},${trailFade})`; tg.fillRect(0,0,W,H); }


  // Pearl ground
  g.fillStyle=`rgba(255,252,245,0.06)`; g.fillRect(0,0,W,H);

  // Glaze layer 1 — base field tint
  {
    const fieldBias = (hueShift+0.1)%1;
    const [fr,fgv,fb] = duskRGB(fieldBias, pieceAge);
    g.fillStyle=`rgba(${fr},${fgv},${fb},0.028)`; g.fillRect(0,0,W,H);
  }

  // Glaze layer 2 — wash blobs
  for(const w of washes){
    w.x+=w.vx; w.y+=w.vy; w.phase+=w.phaseSpeed;
    if(w.x<-0.5)w.x=1.5; if(w.x>1.5)w.x=-0.5;
    if(w.y<-0.5)w.y=1.5; if(w.y>1.5)w.y=-0.5;
    w.opacityActual = (w.opacityActual||0)+(w.opacity-(w.opacityActual||0))*0.003;
    w.bias = ((w.bias||0)+(w.biasDrift||0)+1.0)%1.0;
    const pulse=1+Math.sin(w.phase)*0.06;
    const rPx=(w.r*Math.max(W,H)*1.1)*pulse;
    const wg=g.createRadialGradient(w.x*W,w.y*H,0,w.x*W,w.y*H,rPx);
    const op=Math.min(w.opacityActual*(0.9+Math.sin(w.phase*1.3)*0.1)+swellAlpha*0.18,0.99);
    const [r1,g1,b1]=duskRGB(w.bias, pieceAge);
    const [r2,g2,b2]=duskRGB((w.bias+0.15)%1, pieceAge);
    wg.addColorStop(0,    `rgba(${r1},${g1},${b1},${Math.min(op*0.4,0.99)})`);
    wg.addColorStop(0.3,  `rgba(${r2},${g2},${b2},${Math.min(op*0.18,0.99)})`);
    wg.addColorStop(0.7,  `rgba(${r2},${g2},${b2},${Math.min(op*0.04,0.99)})`);
    wg.addColorStop(1,    'transparent');
    g.fillStyle=wg; g.fillRect(0,0,W,H);
  }

  // Glaze layer 3 — swell shift
  if(swellAlpha>0.003){
    const sg=g.createLinearGradient(0,H,W,0);
    sg.addColorStop(0,   dc(0.68, Math.min(swellAlpha*0.9,0.99), pieceAge));
    sg.addColorStop(0.5, dc(0.52, Math.min(swellAlpha*0.5,0.99), pieceAge));
    sg.addColorStop(1,   'transparent');
    g.fillStyle=sg; g.fillRect(0,0,W,H);
  }

  // Specular sheen
  {
    const sx = 0.5+Math.sin(pieceAge*0.04)*0.35;
    const sy = 0.3+Math.cos(pieceAge*0.028)*0.25;
    const sheenR=Math.min(W,H)*0.7;
    const sheenOp=Math.min(0.04+Math.sin(pieceAge*0.06)*0.02, 0.99);
    const sg2=g.createRadialGradient(sx*W,sy*H,0,sx*W,sy*H,sheenR);
    sg2.addColorStop(0,   `rgba(255,252,248,${Math.min(sheenOp*2,0.99)})`);
    sg2.addColorStop(0.3, `rgba(255,250,245,${Math.min(sheenOp,0.99)})`);
    sg2.addColorStop(1,   'transparent');
    g.fillStyle=sg2; g.fillRect(0,0,W,H);
  }

  // Micro texture
  if(frame%3===0){
    const tx=rand(0,W), ty=rand(0,H), tr2=rand(8,35);
    const tg3=g.createRadialGradient(tx,ty,0,tx,ty,tr2);
    const [tr,tgv,tb]=duskRGB(rand(0,1), pieceAge);
    tg3.addColorStop(0, `rgba(${tr},${tgv},${tb},${rand(0.008,0.028)})`);
    tg3.addColorStop(1, 'transparent');
    g.fillStyle=tg3; g.beginPath(); g.arc(tx,ty,tr2,0,Math.PI*2); g.fill();
  }

  // ── Projector flicker ────────────────────────────────────────────────────────
  // Every ~8-15 seconds a flicker event — brightness dips then flashes
  // Uses a slow decay so you actually see it last a few frames
  if(coin(0.004) && flickerIntensity < 0.01){
    // Randomly either a bright flash or a dim dip
    flickerIntensity = coin(0.5) ? rand(0.12, 0.32) : rand(-0.08, -0.03);
    flickerDecay = rand(0.04, 0.09); // slow decay — lasts ~10-20 frames
  }
  if(Math.abs(flickerIntensity) > 0.002){
    if(flickerIntensity > 0){
      // Bright flash — white wash
      g.fillStyle=`rgba(255,252,245,${Math.min(flickerIntensity,0.99)})`;
      g.fillRect(0,0,W,H);
    } else {
      // Dim dip — dark wash
      g.fillStyle=`rgba(10,8,5,${Math.min(-flickerIntensity,0.99)})`;
      g.fillRect(0,0,W,H);
    }
    flickerIntensity *= (1 - flickerDecay);
  }


  // ── Orb movement ──
  for(let i=0;i<butterflies.length;i++){
    const b=butterflies[i];
    b.angleV += b.angleV2;
    b.angleV = Math.max(-0.00045, Math.min(0.00045, b.angleV));
    if(b.merging) continue;
    if(b.linkedAngleRef && b.linkedUntil > Date.now()/1000){
      b.angle = b.linkedAngleRef.angle + rand(-0.002,0.002);
      b.linkedAngleRef.angle += b.angleV;
    } else { b.angle += b.angleV; }
    b.x += Math.cos(b.angle)*b.speed;
    b.y += Math.sin(b.angle)*b.speed;
    b.trail.push({x:b.x, y:b.y});
    if(b.trail.length > b.trailMax) b.trail.shift();
    if(b.x < -0.08) b.x = 1.08;
    if(b.x >  1.08) b.x = -0.08;
    if(b.y < -0.08) b.y = 1.08;
    if(b.y >  1.08) b.y = -0.08;
    if(b.opacity < b.targetOpacity) b.opacity = Math.min(b.targetOpacity, b.opacity+0.008);
    b.life -= b.decay;
    // Live stereo pan update — pan follows orb's x position in real time
    if(b.pannerRef && b.pannerRef.node && playing) {
      const targetPan = Math.max(-1, Math.min(1, (b.x * 2) - 1));
      // Smooth pan movement — audio pan can't jump instantly
      const currentPan = b.pannerRef.node.pan.value;
      b.pannerRef.node.pan.value = currentPan + (targetPan - currentPan) * 0.05;
    }
  }

  // ── Collision merging ──
  for(let i=butterflies.length-1;i>=1;i--){
    for(let j=i-1;j>=0;j--){
      const a=butterflies[i], b=butterflies[j];
      if(!a||!b) continue;
      if(a.merging||b.merging) continue;
      const dx=(a.x-b.x)*W, dy=(a.y-b.y)*H;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist < (a.size+b.size)*0.85){
        const [surv, gone] = a.size>=b.size ? [b,a] : [a,b];
        const ti = butterflies.indexOf(gone);
        const ts=surv.size*surv.size, tgone=gone.size*gone.size, total=ts+tgone;
        // FIX 3: smaller merge cap — 22px max
        surv.mergeTargetSize = Math.min(Math.sqrt(total), 12);
        surv.mergeTargetX    = (surv.x*ts + gone.x*tgone)/total;
        surv.mergeTargetY    = (surv.y*ts + gone.y*tgone)/total;
        surv.mergeTargetOp   = Math.min((surv.targetOpacity*ts+gone.targetOpacity*tgone)/total, 0.62);
        surv.merging=true; surv.mergeSpeed=0.035;
        surv.life=Math.max(surv.life,gone.life);
        surv.bias=(surv.bias*ts+gone.bias*tgone)/total;
        surv.age=Math.min(surv.age,gone.age);
        surv.trail=[...gone.trail,...surv.trail].slice(-surv.trailMax);
        surv.mergeCount=(surv.mergeCount||0)+(gone.mergeCount||0)+1;
        if(ti>-1) butterflies.splice(ti,1);
        break;
      }
    }
  }

  // ── Animate merging ──
  for(const b of butterflies){
    if(!b.merging) continue;
    b.angle += b.angleV;
    b.mergeTargetX += Math.cos(b.angle)*b.speed;
    b.mergeTargetY += Math.sin(b.angle)*b.speed;
    b.mergeTargetX = Math.max(0.02, Math.min(0.98, b.mergeTargetX));
    b.mergeTargetY = Math.max(0.02, Math.min(0.98, b.mergeTargetY));
    b.x    += (b.mergeTargetX - b.x)    * b.mergeSpeed;
    b.y    += (b.mergeTargetY - b.y)    * b.mergeSpeed;
    b.size += (b.mergeTargetSize - b.size) * b.mergeSpeed;
    b.targetOpacity += (b.mergeTargetOp - b.targetOpacity) * b.mergeSpeed;
    if(Math.abs(b.size-b.mergeTargetSize)<0.3 && Math.abs(b.x-b.mergeTargetX)<0.002 && Math.abs(b.y-b.mergeTargetY)<0.002){
      b.size=b.mergeTargetSize; b.merging=false;
    }
  }

  // ── Draw & cull ──
  for(let i=butterflies.length-1;i>=0;i--){
    const b=butterflies[i];
    if(b.life<=0){butterflies.splice(i,1);continue;}
    const lifeOp = b.life > 0.25 ? b.opacity : b.opacity*(b.life/0.25);

    // Paintbrush stroke — connect last two trail points with a soft line
    if(b.trail.length > 1){
      const mc = b.mergeCount||0;
      const vib = b.vibrancy || 0.5;
      const p0 = b.trail[b.trail.length-2];
      const p1 = b.trail[b.trail.length-1];
      const strokeW = Math.max(0.6, b.size * (0.14 + mc*0.06));
      // Velocity drives opacity — quiet notes barely visible, loud notes vivid
      const tOp = Math.min(b.opacity * (0.18 + vib * 0.32), 0.99);
      // Velocity shifts color — quiet=desaturated/pale, loud=more saturated/shifted
      const biasMod = b.bias + (vib - 0.5) * 0.18;
      const [r1,g1,b1t]=duskRGB(Math.max(0,biasMod-0.15), b.age);
      tg.beginPath();
      tg.moveTo(p0.x*W, p0.y*H);
      tg.lineTo(p1.x*W, p1.y*H);
      tg.strokeStyle = `rgba(${r1},${g1},${b1t},${tOp})`;
      tg.lineWidth = strokeW;
      tg.lineCap = 'round';
      tg.lineJoin = 'round';
      tg.stroke();
    }

    // no orb head — trail only
  }
}
draw();
</script>
</body>
</html>
