<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Afterglow</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IM+Fell+English:ital@0;1&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  :root { --cream:#f0e8d8; --warm:#c8a97a; --dark:#1a1410; }
  body {
    background:var(--dark); color:var(--cream);
    font-family:'IM Fell English',serif;
    height:100dvh; display:flex; flex-direction:column;
    align-items:center; justify-content:center;
    overflow:hidden; user-select:none;
  }
  body::before {
    content:''; position:fixed; inset:0;
    background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
    opacity:0.35; pointer-events:none; z-index:10;
  }
  body::after {
    content:''; position:fixed; inset:0;
    background:radial-gradient(ellipse at center,transparent 30%,rgba(0,0,0,0.78) 100%);
    pointer-events:none; z-index:9;
  }
  canvas { position:fixed; inset:0; width:100%; height:100%; }
  #c { z-index:1; }
  #fill-canvas { z-index:2; pointer-events:none; }
  #trail-canvas { z-index:3; pointer-events:none; }

  .btn-wrap {
    position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
    z-index:20; transition:opacity 3s ease; display:flex; flex-direction:column; align-items:center;
  }
  .btn-wrap.hide { opacity:0; pointer-events:none; }
  .btn {
    width:72px; height:72px; border-radius:50%;
    border:1.5px solid rgba(200,169,122,0.4); background:transparent;
    display:flex; align-items:center; justify-content:center;
    cursor:pointer; transition:border-color 0.8s,transform 0.3s; position:relative;
  }
  .btn::before { content:''; position:absolute; inset:-8px; border-radius:50%; border:1px solid rgba(200,169,122,0.12); }
  .btn:hover { border-color:rgba(200,169,122,0.7); transform:scale(1.05); }
  .hint { font-size:0.62rem; letter-spacing:0.3em; color:var(--cream); opacity:0.22; text-transform:uppercase; margin-top:0.7rem; }

  .corner {
    position:fixed; bottom:2rem; left:2rem;
    z-index:20; display:flex; flex-direction:column; gap:0.4rem;
  }
  .title-row { display:flex; align-items:baseline; gap:0.7em; }
  .stop-btn {
    background:none; border:none; cursor:pointer; padding:0;
    font-family:'IM Fell English',serif; font-style:italic;
    font-size:clamp(0.9rem,2.5vw,1.3rem); letter-spacing:0.15em;
    color:var(--warm); opacity:0; pointer-events:none;
    transition:opacity 2s ease;
  }
  .stop-btn.visible { opacity:0.45; pointer-events:all; }
  .stop-btn:hover { opacity:0.75 !important; }
  .note-indicator { font-size:clamp(0.7rem,2vw,0.9rem); letter-spacing:0.45em; color:var(--warm); opacity:0; transition:opacity 1.4s ease; font-style:italic; min-height:1.1em; }
  .note-indicator.visible { opacity:0.55; }
  .title { font-size:clamp(0.9rem,2.5vw,1.3rem); letter-spacing:0.2em; opacity:0.55; font-weight:normal; }
</style>
</head>
<body>
<canvas id="trail-canvas"></canvas>
<canvas id="fill-canvas"></canvas>
<canvas id="c"></canvas>

<div class="btn-wrap" id="btnWrap">
  <button class="btn" id="playBtn" aria-label="Play">
    <svg id="btnIcon" width="22" height="22" viewBox="0 0 24 24" fill="#c8a97a"><polygon points="5,3 19,12 5,21"/></svg>
  </button>
  <p class="hint" id="hint">tap to begin</p>
</div>

<div class="corner">
  <div class="note-indicator" id="noteDisp"></div>
  <div class="title-row">
    <h1 class="title">Afterglow</h1>
    <button class="stop-btn" id="stopBtn">stop</button>
  </div>
</div>

<script>

const rand = (a,b) => a + Math.random()*(b-a);
const randInt = (a,b) => Math.floor(rand(a,b+1));
const pick = arr => arr[Math.floor(Math.random()*arr.length)];
const coin = p => Math.random() < p;

const MIX = {
  G2:98.00, C3:130.81, D3:146.83, E3:164.81, F3:174.61,
  G3:196.00, A3:220.00, B3:246.94,
  C4:261.63, D4:293.66, E4:329.63, F4:349.23,
  G4:392.00, A4:440.00, B4:493.88,
  C5:523.25, D5:587.33, E5:659.26, F5:698.46,
  G5:784.00, A5:880.00,
};

const MELODY = ['G4','F4','E4','C4','D4','A4'];
const CORE   = ['G4','F4','E4','C4'];
const COLOUR = ['D4','A4'];

const TRANSITIONS = {
  G4: { A4:5, F4:2, E4:2, C4:2, D4:1 },
  F4: { E4:3, C4:3, G4:2, D4:2, A4:1 },
  E4: { C4:3, G4:3, F4:2, A4:2, D4:0 },
  C4: { G4:3, E4:3, F4:2, D4:2, A4:1 },
  D4: { E4:6, G4:2, F4:1, C4:1, A4:1 },
  A4: { E4:3, F4:3, C4:2, D4:2, G4:0 },
};

const VOICINGS = {
  G4: ['G2','D3','G3','B3','D4','G4','B4','D5'],
  F4: ['C3','F3','A3','C4','F4','A4','C5','E5'],
  E4: ['G2','E3','B3','E4','G4','B4','E5'],
  C4: ['G2','C3','G3','C4','E4','G4','C5'],
  D4: ['D3','A3','D4','F4','A4','D5'],
  A4: ['A2','E3','A3','C4','E4','A4','C5'],
  GF: ['G2','F3','C4','F4','A4','C5','F5'],
  GE: ['G2','E3','B3','G4','B4','E5'],
  GC: ['G2','C3','G3','C4','E4','G4','D5'],
  FE: ['C3','E3','A3','C4','F4','A4','C5'],
  FC: ['F3','C4','F4','A4','C5','F5'],
  EC: ['C3','E3','G3','C4','E4','G4','B4'],
  DA: ['D3','A3','D4','E4','A4','D5'],
  GA: ['G2','A3','E4','G4','A4','E5'],
  ALL:['G2','A2','C3','E3','G3','B3','D4','F4','G4','A4','C5'],
};

let ctx, reverb, masterLPF, playing=false, lastNote=null;
let timers=[];
const addTimer=(fn,ms)=>{const t=setTimeout(fn,ms);timers.push(t);return t;};
const clearTimers=()=>{timers.forEach(clearTimeout);timers=[];};

let recentNotes = [];
let noteHistory = [];
let breathPhase = 'building';
let pieceDensity = 1.0;
let swellActive=false, swellIntensity=0;
let nextNoteT=0;

function buildReverb(actx) {
  const sr=actx.sampleRate, dur=5.0, decay=4.0;
  const len=Math.floor(sr*dur);
  const ir=actx.createBuffer(2,len,sr);
  for (let ch=0;ch<2;ch++) {
    const d=ir.getChannelData(ch);
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0;
    for (let i=0;i<len;i++) {
      const w=Math.random()*2-1;
      b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759;
      b2=0.96900*b2+w*0.1538520; b3=0.86650*b3+w*0.3104856;
      b4=0.55000*b4+w*0.5329522; b5=-0.7616*b5-w*0.0168980;
      d[i]=(b0+b1+b2+b3+b4+b5+w*0.5362)*0.11*Math.pow(1-i/len,decay);
    }
  }
  const conv=actx.createConvolver(); conv.buffer=ir; return conv;
}

function makePink(actx,dur) {
  const sr=actx.sampleRate;
  const buf=actx.createBuffer(2,Math.floor(sr*dur),sr);
  for (let ch=0;ch<2;ch++) {
    const d=buf.getChannelData(ch);
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
    for (let i=0;i<d.length;i++) {
      const w=Math.random()*2-1;
      b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759;
      b2=0.96900*b2+w*0.1538520; b3=0.86650*b3+w*0.3104856;
      b4=0.55000*b4+w*0.5329522; b5=-0.7616*b5-w*0.0168980;
      d[i]=(b0+b1+b2+b3+b4+b5+b6+w*0.5362)*0.11; b6=w*0.115926;
    }
  }
  return buf;
}

function tapeCurve(amt=35) {
  const n=256,c=new Float32Array(n);
  for (let i=0;i<n;i++){const x=i*2/n-1;c[i]=(Math.PI+amt)*x/(Math.PI+amt*Math.abs(x));}
  return c;
}

function playNote(actx, freqHz, time, opts={}) {
  const {
    vol=rand(0.10,0.16), decay=rand(4.0,7.0),
    reversed=false, quiet=false, dryWet=0.62,
    wobble=rand(0.997,1.003)
  } = opts;
  const f0=freqHz*wobble;
  const v=quiet?vol*0.4:vol;
  const dryG=actx.createGain(); dryG.gain.value=v*(1-dryWet);
  const wetG=actx.createGain(); wetG.gain.value=v*dryWet;
  dryG.connect(masterLPF); wetG.connect(reverb);
  const preLPF=actx.createBiquadFilter(); preLPF.type='lowpass';
  preLPF.frequency.value=rand(1800,2600); preLPF.Q.value=0.5;
  preLPF.connect(dryG); preLPF.connect(wetG);
  const warmth=actx.createBiquadFilter(); warmth.type='highshelf';
  warmth.frequency.value=4000; warmth.gain.value=rand(-5,-9);
  warmth.connect(preLPF);
  const shaper=actx.createWaveShaper();
  shaper.curve=tapeCurve(rand(20,45)); shaper.oversample='4x';
  shaper.connect(warmth);
  const env=actx.createGain();
  if (reversed) {
    env.gain.setValueAtTime(0.001,time);
    env.gain.exponentialRampToValueAtTime(1.0,time+decay*0.82);
    env.gain.linearRampToValueAtTime(0,time+decay);
  } else {
    env.gain.setValueAtTime(0,time);
    env.gain.linearRampToValueAtTime(1.0,time+0.010);
    env.gain.exponentialRampToValueAtTime(0.38,time+0.15);
    env.gain.exponentialRampToValueAtTime(0.001,time+decay);
  }
  env.connect(shaper);
  const ih=1.0006;
  [
    {m:1.000,      g:1.00,d:1.00},
    {m:2.000*ih,   g:0.48,d:0.55},
    {m:3.000*ih*ih,g:0.22,d:0.35},
    {m:4*Math.pow(ih,3),g:0.12,d:0.22},
    {m:5*Math.pow(ih,4),g:0.06,d:0.15},
    {m:6*Math.pow(ih,5),g:0.03,d:0.10},
  ].forEach(p=>{
    const osc=actx.createOscillator(); osc.type='sine'; osc.frequency.value=f0*p.m;
    if(p.m<1.1){
      const wow=actx.createOscillator(); wow.frequency.value=rand(0.3,0.8);
      const wg=actx.createGain(); wg.gain.value=rand(0.5,1.5);
      wow.connect(wg); wg.connect(osc.frequency);
      wow.start(time); wow.stop(time+decay+2);
    }
    const pg=actx.createGain();
    pg.gain.setValueAtTime(p.g,time);
    pg.gain.exponentialRampToValueAtTime(0.001,time+decay*p.d);
    osc.connect(pg); pg.connect(env);
    osc.start(time); osc.stop(time+decay+2);
  });
  if (!reversed) {
    const hLen=Math.floor(actx.sampleRate*0.035);
    const hb=actx.createBuffer(1,hLen,actx.sampleRate);
    const hd=hb.getChannelData(0);
    for(let i=0;i<hLen;i++) hd[i]=(Math.random()*2-1)*Math.exp(-i/350)*0.6;
    const hs=actx.createBufferSource(); hs.buffer=hb;
    const hbp=actx.createBiquadFilter(); hbp.type='bandpass';
    hbp.frequency.value=rand(600,1100); hbp.Q.value=2;
    const hg=actx.createGain(); hg.gain.value=rand(0.08,0.15);
    hs.connect(hbp); hbp.connect(hg); hg.connect(wetG);
    hs.start(time); hs.stop(time+0.04);
  }
}

function bloomChord(actx) {
  if (!playing || !ctx) return;
  const unique = [...new Set(recentNotes.slice(-6))];
  let voicingKey = 'G4';
  if (unique.length >= 5) { voicingKey = 'ALL'; }
  else if (unique.length >= 4 && unique.includes('G4') && unique.includes('A4')) { voicingKey = 'ALL'; }
  else if (unique.includes('D4') && unique.includes('A4')) { voicingKey = 'DA'; }
  else if (unique.includes('G4') && unique.includes('A4')) { voicingKey = 'GA'; }
  else if (unique.includes('D4')) { voicingKey = 'D4'; }
  else if (unique.includes('A4')) { voicingKey = 'A4'; }
  else if (unique.length >= 4) { voicingKey = 'ALL'; }
  else if (unique.length === 3) {
    voicingKey = unique.includes('G4') && unique.includes('F4') ? 'GF'
               : unique.includes('G4') && unique.includes('E4') ? 'GE'
               : unique.includes('G4') && unique.includes('C4') ? 'GC'
               : unique.includes('F4') && unique.includes('E4') ? 'FE'
               : unique.includes('F4') && unique.includes('C4') ? 'FC' : 'EC';
  } else if (unique.length === 2) {
    if      (unique.includes('G4') && unique.includes('F4')) voicingKey='GF';
    else if (unique.includes('G4') && unique.includes('E4')) voicingKey='GE';
    else if (unique.includes('G4') && unique.includes('C4')) voicingKey='GC';
    else if (unique.includes('F4') && unique.includes('E4')) voicingKey='FE';
    else if (unique.includes('F4') && unique.includes('C4')) voicingKey='FC';
    else if (unique.includes('D4') && unique.includes('A4')) voicingKey='DA';
    else if (unique.includes('G4') && unique.includes('A4')) voicingKey='GA';
    else voicingKey='EC';
  } else if (unique.length === 1) { voicingKey = unique[0]; }

  const notes = VOICINGS[voicingKey] || VOICINGS['G4'];
  const chordDur = rand(8, 16);
  const fadeIn   = rand(2.5, 5);
  const now = actx.currentTime;
  const chordMaster = actx.createGain();
  chordMaster.gain.setValueAtTime(0, now);
  chordMaster.gain.linearRampToValueAtTime(rand(0.06,0.12), now+fadeIn);
  chordMaster.gain.setValueAtTime(rand(0.06,0.12), now+chordDur*0.6);
  chordMaster.gain.linearRampToValueAtTime(0, now+chordDur);
  const chordWet = actx.createGain(); chordWet.gain.value=0.85;
  const chordDry = actx.createGain(); chordDry.gain.value=0.15;
  chordMaster.connect(chordWet); chordWet.connect(reverb);
  chordMaster.connect(chordDry); chordDry.connect(masterLPF);
  const chordLPF = actx.createBiquadFilter();
  chordLPF.type='lowpass'; chordLPF.frequency.value=rand(900,1400); chordLPF.Q.value=0.3;
  chordLPF.connect(chordMaster);
  notes.forEach((noteName, i) => {
    const f = MIX[noteName]; if (!f) return;
    const stagger = i * rand(0.15, 0.4);
    const osc1=actx.createOscillator(); osc1.type='sine'; osc1.frequency.value=f*rand(0.998,1.002);
    const osc2=actx.createOscillator(); osc2.type='sine'; osc2.frequency.value=f*2.001;
    const osc3=actx.createOscillator(); osc3.type='sine'; osc3.frequency.value=f*3.002;
    const og=actx.createGain();
    og.gain.setValueAtTime(0, now+stagger);
    og.gain.linearRampToValueAtTime(1.0/(notes.length*0.7), now+stagger+rand(1,2.5));
    og.gain.setValueAtTime(1.0/(notes.length*0.7), now+chordDur*0.55);
    og.gain.linearRampToValueAtTime(0, now+chordDur-stagger);
    const h2g=actx.createGain(); h2g.gain.value=0.18;
    const h3g=actx.createGain(); h3g.gain.value=0.07;
    osc1.connect(og); og.connect(chordLPF);
    osc2.connect(h2g); h2g.connect(chordLPF);
    osc3.connect(h3g); h3g.connect(chordLPF);
    const end=now+chordDur+2;
    [osc1,osc2,osc3].forEach(o=>{o.start(now+stagger);o.stop(end);});
  });
  chordBloom=true;
  setTimeout(()=>{ chordBloom=false; }, chordDur*1000*0.7);
}

function playOceanSwell(actx) {
  const dur=rand(16,28);
  const buf=makePink(actx,dur);
  const src=actx.createBufferSource(); src.buffer=buf;
  const peak=rand(0.13,0.20);
  const env=actx.createGain();
  env.gain.setValueAtTime(0,actx.currentTime);
  env.gain.linearRampToValueAtTime(peak,actx.currentTime+dur*0.30);
  env.gain.setValueAtTime(peak,actx.currentTime+dur*0.62);
  env.gain.linearRampToValueAtTime(0,actx.currentTime+dur);
  const lpf=actx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=rand(350,550); lpf.Q.value=0.7;
  const body=actx.createBiquadFilter(); body.type='peaking'; body.frequency.value=rand(80,150); body.Q.value=0.5; body.gain.value=rand(4,8);
  const lfo=actx.createOscillator(); lfo.frequency.value=rand(0.03,0.09);
  const lfg=actx.createGain(); lfg.gain.value=rand(0.015,0.04);
  lfo.connect(lfg); lfg.connect(env.gain);
  const sd=actx.createGain(); sd.gain.value=0.55;
  const sw=actx.createGain(); sw.gain.value=0.5;
  src.connect(body); body.connect(lpf); lpf.connect(env);
  env.connect(sd); sd.connect(masterLPF);
  env.connect(sw); sw.connect(reverb);
  lfo.start(); lfo.stop(actx.currentTime+dur);
  src.start(); src.stop(actx.currentTime+dur);
  swellActive=true; swellIntensity=peak/0.20;
  setTimeout(()=>{swellActive=false;swellIntensity=0;},dur*1000);
}

function playPolyLayer(actx, ratio, pulseLen, startT) {
  const step=(pulseLen*4)/ratio;
  for(let i=0;i<ratio;i++){
    const name=pick(MELODY); const f=MIX[name];
    playNote(actx,f,startT+i*step,{vol:rand(0.07,0.11),decay:rand(2.0,3.5),quiet:false,dryWet:0.72});
  }
}

function updateBreathPhase() {
  const phases = ['building','full','withdrawing','silence'];
  const durations = {
    building:  rand(45000,90000), full: rand(30000,60000),
    withdrawing: rand(40000,70000), silence: rand(15000,35000),
  };
  const densities = { building:1.0, full:0.85, withdrawing:1.4, silence:2.8 };
  const next = (current) => { const idx=phases.indexOf(current); return phases[(idx+1)%phases.length]; };
  const transition = () => {
    if (!playing) return;
    breathPhase = next(breathPhase);
    pieceDensity = densities[breathPhase];
    addTimer(transition, durations[breathPhase]);
  };
  addTimer(transition, durations[breathPhase]);
}

function pickMelodyNote() {
  let pool = [];
  if (lastNote && TRANSITIONS[lastNote]) {
    const t = TRANSITIONS[lastNote];
    for (const [note, weight] of Object.entries(t)) {
      for (let i=0; i<weight; i++) pool.push(note);
    }
  } else {
    for (const n of CORE)   { pool.push(n,n,n); }
    for (const n of COLOUR) { pool.push(n); }
  }
  if (noteHistory.length > 16 && coin(0.22) && lastNote) {
    const lookback = Math.floor(rand(4,9));
    const ghost = noteHistory[noteHistory.length - lookback];
    const allowed = TRANSITIONS[lastNote] || {};
    if (ghost && (allowed[ghost] || 0) > 0) { pool.push(ghost, ghost); }
  }
  const filtered = pool.filter(n => n !== lastNote);
  const chosen = filtered.length > 0 ? pick(filtered) : pick(pool);
  lastNote = chosen;
  noteHistory.push(chosen);
  recentNotes.push(chosen);
  if (recentNotes.length > 8) recentNotes.shift();
  if (noteHistory.length > 200) noteHistory.shift();
  return chosen;
}

const noteDisp=document.getElementById('noteDisp');

function scheduleMain() {
  if (!playing||!ctx) return;
  const name = pickMelodyNote();
  const f = MIX[name];
  const isRev = coin(0.12);
  const baseGap = rand(2.8,6.2);
  const gap = baseGap * pieceDensity;
  const noteVol = rand(0.10,0.16);
  const noteDecay = rand(4.0,7.0);
  nextNoteT += gap;
  playNote(ctx, f, nextNoteT, { reversed:isRev, dryWet:0.62, vol:noteVol, decay:noteDecay });
  const ms = Math.max(0,(nextNoteT-ctx.currentTime)*1000);
  addTimer(()=>{ if(!playing) return; triggerPulse(isRev, noteVol, noteDecay); }, ms);
  addTimer(scheduleMain,(gap-1.4)*1000);
}

function scheduleChordBloom() {
  if(!playing||!ctx) return;
  const wait = rand(12000,22000);
  addTimer(()=>{
    if(!playing||!ctx) return;
    if([...new Set(recentNotes)].length >= 4) bloomChord(ctx);
    scheduleChordBloom();
  }, wait);
}

function schedulePolyrhythm() {
  if(!playing||!ctx) return;
  addTimer(()=>{
    if(!playing||!ctx) return;
    if(breathPhase !== 'silence') {
      const ratio=coin(0.5)?5:6, pulse=rand(1.0,1.7);
      const t0=ctx.currentTime+0.5;
      playPolyLayer(ctx,ratio,pulse,t0);
      playPolyLayer(ctx,ratio,pulse,t0+pulse*4+rand(0.5,1.5));
      for(let pi=0;pi<ratio;pi++) setTimeout(triggerPolyOrb, pi*(pulse*4/ratio)*1000);
    }
    schedulePolyrhythm();
  }, rand(20000,45000));
}

function scheduleOceanSwell() {
  if(!playing||!ctx) return;
  addTimer(()=>{
    if(!playing||!ctx) return;
    if(!swellActive) playOceanSwell(ctx);
    scheduleOceanSwell();
  }, rand(18000,40000));
}

function startMusic() {
  ctx = new (window.AudioContext||window.webkitAudioContext)();
  reverb = buildReverb(ctx);
  const limiter = ctx.createDynamicsCompressor();
  limiter.threshold.value=-3; limiter.knee.value=0; limiter.ratio.value=20;
  limiter.attack.value=0.001; limiter.release.value=0.1;
  limiter.connect(ctx.destination);
  const compressor = ctx.createDynamicsCompressor();
  compressor.threshold.value=-18; compressor.knee.value=10; compressor.ratio.value=3;
  compressor.attack.value=0.02; compressor.release.value=0.4;
  compressor.connect(limiter);
  const masterGain = ctx.createGain(); masterGain.gain.value=0.7;
  masterGain.connect(compressor);
  masterLPF = ctx.createBiquadFilter();
  masterLPF.type='lowpass'; masterLPF.frequency.value=5500; masterLPF.Q.value=0.4;
  masterLPF.frequency.setValueAtTime(5500,ctx.currentTime);
  masterLPF.frequency.linearRampToValueAtTime(3800,ctx.currentTime+90);
  masterLPF.frequency.linearRampToValueAtTime(5000,ctx.currentTime+180);
  masterLPF.connect(masterGain);
  reverb.connect(masterGain);
  nextNoteT = ctx.currentTime+0.8;
  breathPhase='building'; pieceDensity=1.0;
  pieceStartTime = Date.now();
  scheduleMain(); scheduleChordBloom(); schedulePolyrhythm(); updateBreathPhase();
  addTimer(()=>{ if(playing&&ctx) playOceanSwell(ctx); }, rand(6000,14000));
  scheduleOceanSwell();
}

function stopMusic() {
  clearTimers();
  if(ctx){ctx.close();ctx=null;}
  recentNotes=[]; noteHistory=[]; lastNote=null;
  noteDisp.textContent=''; noteDisp.classList.remove('visible');
}

const btn=document.getElementById('playBtn');
const btnWrap=document.getElementById('btnWrap');
const stopBtn=document.getElementById('stopBtn');
let btnHideTimer=null;

stopBtn.addEventListener('click',()=>{
  playing=false; stopMusic(); stopBtn.classList.remove('visible');
  butterflies.length=0; btnWrap.style.display='flex'; btnWrap.style.opacity='1';
  document.getElementById('btnIcon').outerHTML=`<svg id="btnIcon" width="22" height="22" viewBox="0 0 24 24" fill="#c8a97a"><polygon points="5,3 19,12 5,21"/></svg>`;
  document.getElementById('hint').style.opacity='0.22';
});

btn.addEventListener('click',()=>{
  playing=!playing;
  if(playing){
    startMusic();
    document.getElementById('btnIcon').outerHTML=`<svg id="btnIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#c8a97a" stroke-width="2.2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>`;
    document.getElementById('hint').style.opacity='0';
    btnHideTimer = setTimeout(()=>{ btnWrap.style.display='none'; }, 2000);
    setTimeout(()=>{ if(playing) document.getElementById('stopBtn').classList.add('visible'); }, 20000);
  } else {
    stopMusic(); clearTimeout(btnHideTimer); btnWrap.classList.remove('hide');
    document.getElementById('btnIcon').outerHTML=`<svg id="btnIcon" width="22" height="22" viewBox="0 0 24 24" fill="#c8a97a"><polygon points="5,3 19,12 5,21"/></svg>`;
  }
});

// ── Canvas ────────────────────────────────────────────────────────────────────
const trailCanvas=document.getElementById('trail-canvas'), tg=trailCanvas.getContext('2d');
const fillCanvas=document.getElementById('fill-canvas'),   fg=fillCanvas.getContext('2d');
const canvas=document.getElementById('c'), g=canvas.getContext('2d');
let W,H;
const resize=()=>{
  W=canvas.width=trailCanvas.width=fillCanvas.width=window.innerWidth;
  H=canvas.height=trailCanvas.height=fillCanvas.height=window.innerHeight;
};
resize(); window.addEventListener('resize',resize);

let pieceAge=0, pieceStartTime=null;
let hueShift=0, hueTarget=0;

const WHEEL = [
  {r:248,g:195,b: 95},
  {r:252,g:220,b:110},
  {r:245,g:168,b:105},
  {r:238,g:128,b:138},
  {r:210,g:115,b:175},
  {r:165,g:128,b:215},
  {r:118,g:145,b:225},
  {r:105,g:175,b:210},
  {r:248,g:195,b: 95},
];

function wheelRGB(hue) {
  const h = ((hue % 1.0) + 1.0) % 1.0;
  const seg = h * (WHEEL.length-1);
  const i = Math.min(Math.floor(seg), WHEEL.length-2);
  const s = seg - i;
  const a=WHEEL[i], b2=WHEEL[i+1];
  return [Math.round(a.r+(b2.r-a.r)*s), Math.round(a.g+(b2.g-a.g)*s), Math.round(a.b+(b2.b-a.b)*s)];
}

function duskRGB(bias, age) {
  const baseHue = hueShift + bias * 0.28;
  const [r,gv,bv] = wheelRGB(baseHue);
  return [Math.max(0,Math.min(255,r)), Math.max(0,Math.min(255,gv)), Math.max(0,Math.min(255,bv))];
}
function dc(bias, opacity, age){ const [r,gv,b]=duskRGB(bias,age); return `rgba(${r},${gv},${b},${Math.min(Math.max(opacity,0),0.99)})`; }

// ── FIX 1: Seeds — wider hue spread, faster cycling, more opaque ──────────────
const seeds = Array.from({length:18},(_,si)=>({
  x: rand(0.02, 0.98), y: rand(0.02, 0.98),
  vx: rand(-0.000025, 0.000025), vy: rand(-0.000020, 0.000020),
  hue: si/18,                              // evenly spaced across full wheel
  hueSpeed: rand(0.00008, 0.00018),        // faster — colors visibly shift
  opacity: 0, targetOp: rand(0.13, 0.22), // more opaque — clearly distinct regions
  phase: rand(0, Math.PI*2), phaseSpeed: rand(0.0003, 0.0008),
}));

const washes = Array.from({length:9},(_,wi)=>({
  x:rand(0.0,1.0), y:rand(0.0,1.0),
  vx:rand(-0.00004,0.00004), vy:rand(-0.00003,0.00003),
  r:rand(0.32,0.62),
  bias: wi/9,
  biasDrift: rand(-0.0003,0.0003),
  opacity:rand(0.028,0.058),
  opacityActual:0,
  phase:rand(0,Math.PI*2),
  phaseSpeed:rand(0.0002,0.0006)
}));

let butterflies=[];

function spawnButterfly(opts={}) {
  const {vol=rand(0.10,0.15), decay=rand(4,7), rev=false}=opts;
  const baseSize = rand(10,18)*(0.7+vol*1.0);
  butterflies.push({
    x: rand(0.08, 0.92), y: rand(0.15, 0.85),
    speed: rand(0.00010, 0.00018),
    angle: rand(0, Math.PI*2),
    angleV: rand(-0.00004, 0.00004),
    angleV2: rand(-0.000004, 0.000004),
    sinX:0, sinXSpeed:0, sinXAmp:0, sinY:0, sinYSpeed:0, sinYAmp:0,
    size: baseSize, opacity: 0,
    targetOpacity: rand(0.28, 0.55),
    life: 1.0, decay: 0.00012 + (1/decay)*0.0001,
    rev, bias: rev ? rand(0.55,0.95) : rand(0.05,0.55),
    age: pieceAge, trail: [], trailMax: 280, mergeCount: 0,
  });
}

function spawnOrbAt(x, y, angle, opts={}) {
  const {vol=rand(0.10,0.15), decay=rand(4,7), rev=false, linkedAngleRef=null}=opts;
  const baseSize = rand(10,18)*(0.7+vol*1.0);
  const orb = {
    x, y, speed: rand(0.00010, 0.00018), angle,
    angleV: rand(-0.00004, 0.00004), angleV2: rand(-0.000004, 0.000004),
    sinX:0, sinXSpeed:0, sinXAmp:0, sinY:0, sinYSpeed:0, sinYAmp:0,
    size: baseSize, opacity: 0, targetOpacity: rand(0.28, 0.55),
    life: 1.0, decay: 0.00012 + (1/decay)*0.0001,
    rev, bias: rev ? rand(0.55,0.95) : rand(0.05,0.55),
    age: pieceAge, trail: [], trailMax: 280, mergeCount: 0,
    linkedAngleRef, linkedUntil: linkedAngleRef ? (Date.now()/1000 + 10) : 0,
  };
  butterflies.push(orb); return orb;
}

let pulses=[], chordBloom=false;

function triggerPulse(rev=false, vol=0.13, decay=5){ spawnButterfly({vol, decay, rev}); }
function triggerPolyOrb(){ spawnButterfly({vol:rand(0.05,0.08), decay:rand(2,4), rev:false}); }

function triggerChordVisual(){
  chordBloomAlpha = 0.06;
  const sharedAngle = rand(0, Math.PI*2);
  const cx = rand(0.25, 0.75), cy = rand(0.25, 0.75);
  const angleRef = {angle: sharedAngle};
  const spread = 0.04;
  for(let i=0;i<3;i++){
    const ox = cx + (i-1)*spread*Math.cos(sharedAngle + Math.PI*0.5);
    const oy = cy + (i-1)*spread*Math.sin(sharedAngle + Math.PI*0.5);
    spawnOrbAt(ox, oy, sharedAngle, {vol:rand(0.07,0.11), decay:rand(8,14), rev:false, linkedAngleRef: angleRef});
  }
}

let swellAlpha=0, swellTarget=0, chordBloomAlpha=0, swellErase=0;
setInterval(()=>{ swellTarget=swellActive?rand(0.025,0.055)*swellIntensity:0; },1500);

let lastChordBloom=false, frame=0;

function draw(){
  requestAnimationFrame(draw); frame++;
  if(chordBloom&&!lastChordBloom) triggerChordVisual();
  lastChordBloom=chordBloom;
  if(pieceStartTime) pieceAge=(Date.now()-pieceStartTime)/1000;
  hueShift += 0.000035;
  if(swellAlpha > 0.01){
    const swellHue = 0.62 + Math.sin(pieceAge*0.08)*0.08;
    hueShift += (swellHue - ((hueShift%1+1)%1)) * swellAlpha * 0.008;
  }
  swellAlpha += (swellTarget-swellAlpha)*0.003;
  chordBloomAlpha *= 0.985;

  const t = Math.min(pieceAge/320,1);
  const bgR=Math.round(255-t*8), bgG=Math.round(250-t*10), bgB=Math.round(242-t*6);

  if(swellActive){ swellErase += (Math.min(swellIntensity*0.85,0.92)-swellErase)*0.003; }
  else           { swellErase += (0-swellErase)*0.001; }

  const baseFade = breathPhase==='silence'?0.0014:0.0003;
  const trailFade = baseFade + swellErase*0.016;
  if(frame%2===0){ tg.fillStyle=`rgba(${bgR},${bgG},${bgB},${trailFade})`; tg.fillRect(0,0,W,H); }
  const fillFade = baseFade*0.6 + swellErase*0.012;
  if(frame%4===0){ fg.fillStyle=`rgba(${bgR},${bgG},${bgB},${Math.min(fillFade,0.99)})`; fg.fillRect(0,0,W,H); }

  // ── Voronoi seed region fills ─────────────────────────────────────────────────
  if(frame%2===0){
    for(const s of seeds){
      s.x += s.vx; s.y += s.vy;
      if(s.x<0) s.x=1; if(s.x>1) s.x=0;
      if(s.y<0) s.y=1; if(s.y>1) s.y=0;
      s.hue = (s.hue + s.hueSpeed) % 1;
      s.phase += s.phaseSpeed;
      s.opacity += (s.targetOp - s.opacity) * 0.005;
      let minDist = 1e9;
      for(const s2 of seeds){
        if(s2===s) continue;
        const dx=(s.x-s2.x)*W, dy=(s.y-s2.y)*H;
        minDist = Math.min(minDist, Math.sqrt(dx*dx+dy*dy));
      }
      const paintR = Math.min(minDist*0.68, Math.min(W,H)*0.42);
      const pulse  = 1 + Math.sin(s.phase)*0.07;
      const r0     = paintR * pulse;
      const sOp    = Math.min(s.opacity*(0.85+Math.sin(s.phase*1.3)*0.15), 0.99);
      const [sr,sgv,sb]    = duskRGB(s.hue, pieceAge);
      const [sr2,sgv2,sb2] = duskRGB((s.hue+0.14)%1, pieceAge);
      const sfg = fg.createRadialGradient(s.x*W, s.y*H, 0, s.x*W, s.y*H, r0);
      // FIX 1: bolder fills — flat inner zone before falling off
      sfg.addColorStop(0,    `rgba(${sr},${sgv},${sb},${Math.min(sOp,0.99)})`);
      sfg.addColorStop(0.38, `rgba(${sr},${sgv},${sb},${Math.min(sOp*0.65,0.99)})`);
      sfg.addColorStop(0.65, `rgba(${sr2},${sgv2},${sb2},${Math.min(sOp*0.22,0.99)})`);
      sfg.addColorStop(1,    'transparent');
      fg.beginPath(); fg.arc(s.x*W, s.y*H, r0, 0, Math.PI*2);
      fg.fillStyle=sfg; fg.fill();
    }
  }

  // Pearl ground
  g.fillStyle=`rgba(255,252,245,0.06)`; g.fillRect(0,0,W,H);

  // Glaze layer 1 — base field tint
  {
    const fieldBias = (hueShift+0.1)%1;
    const [fr,fgv,fb] = duskRGB(fieldBias, pieceAge);
    g.fillStyle=`rgba(${fr},${fgv},${fb},0.028)`; g.fillRect(0,0,W,H);
  }

  // Glaze layer 2 — wash blobs
  for(const w of washes){
    w.x+=w.vx; w.y+=w.vy; w.phase+=w.phaseSpeed;
    if(w.x<-0.5)w.x=1.5; if(w.x>1.5)w.x=-0.5;
    if(w.y<-0.5)w.y=1.5; if(w.y>1.5)w.y=-0.5;
    w.opacityActual = (w.opacityActual||0)+(w.opacity-(w.opacityActual||0))*0.003;
    w.bias = ((w.bias||0)+(w.biasDrift||0)+1.0)%1.0;
    const pulse=1+Math.sin(w.phase)*0.06;
    const rPx=(w.r*Math.max(W,H)*1.1)*pulse;
    const wg=g.createRadialGradient(w.x*W,w.y*H,0,w.x*W,w.y*H,rPx);
    const op=Math.min(w.opacityActual*(0.9+Math.sin(w.phase*1.3)*0.1)+swellAlpha*0.18,0.99);
    const [r1,g1,b1]=duskRGB(w.bias, pieceAge);
    const [r2,g2,b2]=duskRGB((w.bias+0.15)%1, pieceAge);
    wg.addColorStop(0,    `rgba(${r1},${g1},${b1},${Math.min(op*0.85,0.99)})`);
    wg.addColorStop(0.4,  `rgba(${r2},${g2},${b2},${Math.min(op*0.38,0.99)})`);
    wg.addColorStop(0.75, `rgba(${r2},${g2},${b2},${Math.min(op*0.08,0.99)})`);
    wg.addColorStop(1,    'transparent');
    g.fillStyle=wg; g.fillRect(0,0,W,H);
  }

  // Glaze layer 3 — swell shift
  if(swellAlpha>0.003){
    const sg=g.createLinearGradient(0,H,W,0);
    sg.addColorStop(0,   dc(0.68, Math.min(swellAlpha*0.9,0.99), pieceAge));
    sg.addColorStop(0.5, dc(0.52, Math.min(swellAlpha*0.5,0.99), pieceAge));
    sg.addColorStop(1,   'transparent');
    g.fillStyle=sg; g.fillRect(0,0,W,H);
  }

  // Specular sheen
  {
    const sx = 0.5+Math.sin(pieceAge*0.04)*0.35;
    const sy = 0.3+Math.cos(pieceAge*0.028)*0.25;
    const sheenR=Math.min(W,H)*0.7;
    const sheenOp=Math.min(0.04+Math.sin(pieceAge*0.06)*0.02, 0.99);
    const sg2=g.createRadialGradient(sx*W,sy*H,0,sx*W,sy*H,sheenR);
    sg2.addColorStop(0,   `rgba(255,252,248,${Math.min(sheenOp*2,0.99)})`);
    sg2.addColorStop(0.3, `rgba(255,250,245,${Math.min(sheenOp,0.99)})`);
    sg2.addColorStop(1,   'transparent');
    g.fillStyle=sg2; g.fillRect(0,0,W,H);
  }

  // Micro texture
  if(frame%3===0){
    const tx=rand(0,W), ty=rand(0,H), tr2=rand(8,35);
    const tg3=g.createRadialGradient(tx,ty,0,tx,ty,tr2);
    const [tr,tgv,tb]=duskRGB(rand(0,1), pieceAge);
    tg3.addColorStop(0, `rgba(${tr},${tgv},${tb},${rand(0.008,0.028)})`);
    tg3.addColorStop(1, 'transparent');
    g.fillStyle=tg3; g.beginPath(); g.arc(tx,ty,tr2,0,Math.PI*2); g.fill();
  }

  // ── Orb movement ──
  for(let i=0;i<butterflies.length;i++){
    const b=butterflies[i];
    b.angleV += b.angleV2;
    b.angleV = Math.max(-0.00045, Math.min(0.00045, b.angleV));
    if(b.merging) continue;
    if(b.linkedAngleRef && b.linkedUntil > Date.now()/1000){
      b.angle = b.linkedAngleRef.angle + rand(-0.002,0.002);
      b.linkedAngleRef.angle += b.angleV;
    } else { b.angle += b.angleV; }
    b.x += Math.cos(b.angle)*b.speed;
    b.y += Math.sin(b.angle)*b.speed;
    b.trail.push({x:b.x, y:b.y});
    if(b.trail.length > b.trailMax) b.trail.shift();
    if(b.x < -0.08) b.x = 1.08;
    if(b.x >  1.08) b.x = -0.08;
    if(b.y < -0.08) b.y = 1.08;
    if(b.y >  1.08) b.y = -0.08;
    if(b.opacity < b.targetOpacity) b.opacity = Math.min(b.targetOpacity, b.opacity+0.008);
    b.life -= b.decay;
  }

  // ── Collision merging ──
  for(let i=butterflies.length-1;i>=1;i--){
    for(let j=i-1;j>=0;j--){
      const a=butterflies[i], b=butterflies[j];
      if(!a||!b) continue;
      if(a.merging||b.merging) continue;
      const dx=(a.x-b.x)*W, dy=(a.y-b.y)*H;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist < (a.size+b.size)*0.85){
        const [surv, gone] = a.size>=b.size ? [b,a] : [a,b];
        const ti = butterflies.indexOf(gone);
        const ts=surv.size*surv.size, tgone=gone.size*gone.size, total=ts+tgone;
        // FIX 3: smaller merge cap — 22px max
        surv.mergeTargetSize = Math.min(Math.sqrt(total), 22);
        surv.mergeTargetX    = (surv.x*ts + gone.x*tgone)/total;
        surv.mergeTargetY    = (surv.y*ts + gone.y*tgone)/total;
        surv.mergeTargetOp   = Math.min((surv.targetOpacity*ts+gone.targetOpacity*tgone)/total, 0.62);
        surv.merging=true; surv.mergeSpeed=0.035;
        surv.life=Math.max(surv.life,gone.life);
        surv.bias=(surv.bias*ts+gone.bias*tgone)/total;
        surv.age=Math.min(surv.age,gone.age);
        surv.trail=[...gone.trail,...surv.trail].slice(-surv.trailMax);
        surv.mergeCount=(surv.mergeCount||0)+(gone.mergeCount||0)+1;
        if(ti>-1) butterflies.splice(ti,1);
        break;
      }
    }
  }

  // ── Animate merging ──
  for(const b of butterflies){
    if(!b.merging) continue;
    b.angle += b.angleV;
    b.mergeTargetX += Math.cos(b.angle)*b.speed;
    b.mergeTargetY += Math.sin(b.angle)*b.speed;
    b.mergeTargetX = Math.max(0.02, Math.min(0.98, b.mergeTargetX));
    b.mergeTargetY = Math.max(0.02, Math.min(0.98, b.mergeTargetY));
    b.x    += (b.mergeTargetX - b.x)    * b.mergeSpeed;
    b.y    += (b.mergeTargetY - b.y)    * b.mergeSpeed;
    b.size += (b.mergeTargetSize - b.size) * b.mergeSpeed;
    b.targetOpacity += (b.mergeTargetOp - b.targetOpacity) * b.mergeSpeed;
    if(Math.abs(b.size-b.mergeTargetSize)<0.3 && Math.abs(b.x-b.mergeTargetX)<0.002 && Math.abs(b.y-b.mergeTargetY)<0.002){
      b.size=b.mergeTargetSize; b.merging=false;
    }
  }

  // ── Draw & cull ──
  for(let i=butterflies.length-1;i>=0;i--){
    const b=butterflies[i];
    if(b.life<=0){butterflies.splice(i,1);continue;}
    const lifeOp = b.life > 0.25 ? b.opacity : b.opacity*(b.life/0.25);

    // FIX 2: thinner trail dots
    if(b.trail.length > 1){
      const px=b.x*W, py=b.y*H;
      const mc = b.mergeCount||0;
      const spread = Math.min(1.0 + mc*0.55, 3.2);
      const dotR = b.size * 0.28 * spread;  // thinner — was 0.55
      const tOp    = Math.min(b.opacity * 0.42, 0.99);  // less opaque — was 0.62
      const tOpMid = Math.min(tOp * 0.4, 0.99);
      const [r1,g1,b1t]=duskRGB(Math.max(0,b.bias-0.2), b.age);
      const [r2,g2,b2t]=duskRGB(Math.min(1,b.bias+0.2), b.age);
      const tg2=tg.createRadialGradient(px,py,0,px,py,dotR);
      tg2.addColorStop(0,   `rgba(${r1},${g1},${b1t},${tOp})`);
      tg2.addColorStop(0.5, `rgba(${r2},${g2},${b2t},${tOpMid})`);
      tg2.addColorStop(1,   `rgba(${r2},${g2},${b2t},0)`);
      tg.beginPath(); tg.arc(px,py,dotR,0,Math.PI*2);
      tg.fillStyle=tg2; tg.fill();
    }

    const px=b.x*W, py=b.y*H, sr=b.size;
    const mc = b.mergeCount||0;
    const spread = Math.min(1.0 + mc*0.55, 3.2);
    const coreOp = Math.min(lifeOp * Math.max(0.25, 1.0 - mc*0.18), 0.99);
    const edgeOp = Math.min(lifeOp * Math.max(0.0,  0.45 - mc*0.08), 0.99);
    const rad = sr * spread;
    const og=g.createRadialGradient(px,py,0,px,py,rad);
    const [r1,g1,b1]=duskRGB(Math.max(0,b.bias-0.2), b.age);
    const [r2,g2,b2]=duskRGB(Math.min(1,b.bias+0.25), b.age);
    const midStop = mc===0 ? 0.35 : Math.min(0.55 + mc*0.05, 0.92);
    og.addColorStop(0,       `rgba(${r1},${g1},${b1},${coreOp})`);
    og.addColorStop(midStop, `rgba(${r2},${g2},${b2},${edgeOp})`);
    og.addColorStop(1,       `rgba(${r2},${g2},${b2},0)`);
    g.beginPath(); g.arc(px,py,rad,0,Math.PI*2);
    g.fillStyle=og; g.fill();
    if(mc===0){
      g.beginPath(); g.arc(px,py,Math.max(1.5,sr*0.28),0,Math.PI*2);
      g.fillStyle=`rgba(${r1},${g1},${b1},${Math.min(lifeOp*0.7,0.99)})`;
      g.fill();
    }
  }
}
draw();
</script>
</body>
</html>
